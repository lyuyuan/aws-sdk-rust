<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `dynamodb&#x2F;src&#x2F;serializer.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>serializer.rs - source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../aws_sdk_dynamodb/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input"name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">   1</span>
<span id="2">   2</span>
<span id="3">   3</span>
<span id="4">   4</span>
<span id="5">   5</span>
<span id="6">   6</span>
<span id="7">   7</span>
<span id="8">   8</span>
<span id="9">   9</span>
<span id="10">  10</span>
<span id="11">  11</span>
<span id="12">  12</span>
<span id="13">  13</span>
<span id="14">  14</span>
<span id="15">  15</span>
<span id="16">  16</span>
<span id="17">  17</span>
<span id="18">  18</span>
<span id="19">  19</span>
<span id="20">  20</span>
<span id="21">  21</span>
<span id="22">  22</span>
<span id="23">  23</span>
<span id="24">  24</span>
<span id="25">  25</span>
<span id="26">  26</span>
<span id="27">  27</span>
<span id="28">  28</span>
<span id="29">  29</span>
<span id="30">  30</span>
<span id="31">  31</span>
<span id="32">  32</span>
<span id="33">  33</span>
<span id="34">  34</span>
<span id="35">  35</span>
<span id="36">  36</span>
<span id="37">  37</span>
<span id="38">  38</span>
<span id="39">  39</span>
<span id="40">  40</span>
<span id="41">  41</span>
<span id="42">  42</span>
<span id="43">  43</span>
<span id="44">  44</span>
<span id="45">  45</span>
<span id="46">  46</span>
<span id="47">  47</span>
<span id="48">  48</span>
<span id="49">  49</span>
<span id="50">  50</span>
<span id="51">  51</span>
<span id="52">  52</span>
<span id="53">  53</span>
<span id="54">  54</span>
<span id="55">  55</span>
<span id="56">  56</span>
<span id="57">  57</span>
<span id="58">  58</span>
<span id="59">  59</span>
<span id="60">  60</span>
<span id="61">  61</span>
<span id="62">  62</span>
<span id="63">  63</span>
<span id="64">  64</span>
<span id="65">  65</span>
<span id="66">  66</span>
<span id="67">  67</span>
<span id="68">  68</span>
<span id="69">  69</span>
<span id="70">  70</span>
<span id="71">  71</span>
<span id="72">  72</span>
<span id="73">  73</span>
<span id="74">  74</span>
<span id="75">  75</span>
<span id="76">  76</span>
<span id="77">  77</span>
<span id="78">  78</span>
<span id="79">  79</span>
<span id="80">  80</span>
<span id="81">  81</span>
<span id="82">  82</span>
<span id="83">  83</span>
<span id="84">  84</span>
<span id="85">  85</span>
<span id="86">  86</span>
<span id="87">  87</span>
<span id="88">  88</span>
<span id="89">  89</span>
<span id="90">  90</span>
<span id="91">  91</span>
<span id="92">  92</span>
<span id="93">  93</span>
<span id="94">  94</span>
<span id="95">  95</span>
<span id="96">  96</span>
<span id="97">  97</span>
<span id="98">  98</span>
<span id="99">  99</span>
<span id="100"> 100</span>
<span id="101"> 101</span>
<span id="102"> 102</span>
<span id="103"> 103</span>
<span id="104"> 104</span>
<span id="105"> 105</span>
<span id="106"> 106</span>
<span id="107"> 107</span>
<span id="108"> 108</span>
<span id="109"> 109</span>
<span id="110"> 110</span>
<span id="111"> 111</span>
<span id="112"> 112</span>
<span id="113"> 113</span>
<span id="114"> 114</span>
<span id="115"> 115</span>
<span id="116"> 116</span>
<span id="117"> 117</span>
<span id="118"> 118</span>
<span id="119"> 119</span>
<span id="120"> 120</span>
<span id="121"> 121</span>
<span id="122"> 122</span>
<span id="123"> 123</span>
<span id="124"> 124</span>
<span id="125"> 125</span>
<span id="126"> 126</span>
<span id="127"> 127</span>
<span id="128"> 128</span>
<span id="129"> 129</span>
<span id="130"> 130</span>
<span id="131"> 131</span>
<span id="132"> 132</span>
<span id="133"> 133</span>
<span id="134"> 134</span>
<span id="135"> 135</span>
<span id="136"> 136</span>
<span id="137"> 137</span>
<span id="138"> 138</span>
<span id="139"> 139</span>
<span id="140"> 140</span>
<span id="141"> 141</span>
<span id="142"> 142</span>
<span id="143"> 143</span>
<span id="144"> 144</span>
<span id="145"> 145</span>
<span id="146"> 146</span>
<span id="147"> 147</span>
<span id="148"> 148</span>
<span id="149"> 149</span>
<span id="150"> 150</span>
<span id="151"> 151</span>
<span id="152"> 152</span>
<span id="153"> 153</span>
<span id="154"> 154</span>
<span id="155"> 155</span>
<span id="156"> 156</span>
<span id="157"> 157</span>
<span id="158"> 158</span>
<span id="159"> 159</span>
<span id="160"> 160</span>
<span id="161"> 161</span>
<span id="162"> 162</span>
<span id="163"> 163</span>
<span id="164"> 164</span>
<span id="165"> 165</span>
<span id="166"> 166</span>
<span id="167"> 167</span>
<span id="168"> 168</span>
<span id="169"> 169</span>
<span id="170"> 170</span>
<span id="171"> 171</span>
<span id="172"> 172</span>
<span id="173"> 173</span>
<span id="174"> 174</span>
<span id="175"> 175</span>
<span id="176"> 176</span>
<span id="177"> 177</span>
<span id="178"> 178</span>
<span id="179"> 179</span>
<span id="180"> 180</span>
<span id="181"> 181</span>
<span id="182"> 182</span>
<span id="183"> 183</span>
<span id="184"> 184</span>
<span id="185"> 185</span>
<span id="186"> 186</span>
<span id="187"> 187</span>
<span id="188"> 188</span>
<span id="189"> 189</span>
<span id="190"> 190</span>
<span id="191"> 191</span>
<span id="192"> 192</span>
<span id="193"> 193</span>
<span id="194"> 194</span>
<span id="195"> 195</span>
<span id="196"> 196</span>
<span id="197"> 197</span>
<span id="198"> 198</span>
<span id="199"> 199</span>
<span id="200"> 200</span>
<span id="201"> 201</span>
<span id="202"> 202</span>
<span id="203"> 203</span>
<span id="204"> 204</span>
<span id="205"> 205</span>
<span id="206"> 206</span>
<span id="207"> 207</span>
<span id="208"> 208</span>
<span id="209"> 209</span>
<span id="210"> 210</span>
<span id="211"> 211</span>
<span id="212"> 212</span>
<span id="213"> 213</span>
<span id="214"> 214</span>
<span id="215"> 215</span>
<span id="216"> 216</span>
<span id="217"> 217</span>
<span id="218"> 218</span>
<span id="219"> 219</span>
<span id="220"> 220</span>
<span id="221"> 221</span>
<span id="222"> 222</span>
<span id="223"> 223</span>
<span id="224"> 224</span>
<span id="225"> 225</span>
<span id="226"> 226</span>
<span id="227"> 227</span>
<span id="228"> 228</span>
<span id="229"> 229</span>
<span id="230"> 230</span>
<span id="231"> 231</span>
<span id="232"> 232</span>
<span id="233"> 233</span>
<span id="234"> 234</span>
<span id="235"> 235</span>
<span id="236"> 236</span>
<span id="237"> 237</span>
<span id="238"> 238</span>
<span id="239"> 239</span>
<span id="240"> 240</span>
<span id="241"> 241</span>
<span id="242"> 242</span>
<span id="243"> 243</span>
<span id="244"> 244</span>
<span id="245"> 245</span>
<span id="246"> 246</span>
<span id="247"> 247</span>
<span id="248"> 248</span>
<span id="249"> 249</span>
<span id="250"> 250</span>
<span id="251"> 251</span>
<span id="252"> 252</span>
<span id="253"> 253</span>
<span id="254"> 254</span>
<span id="255"> 255</span>
<span id="256"> 256</span>
<span id="257"> 257</span>
<span id="258"> 258</span>
<span id="259"> 259</span>
<span id="260"> 260</span>
<span id="261"> 261</span>
<span id="262"> 262</span>
<span id="263"> 263</span>
<span id="264"> 264</span>
<span id="265"> 265</span>
<span id="266"> 266</span>
<span id="267"> 267</span>
<span id="268"> 268</span>
<span id="269"> 269</span>
<span id="270"> 270</span>
<span id="271"> 271</span>
<span id="272"> 272</span>
<span id="273"> 273</span>
<span id="274"> 274</span>
<span id="275"> 275</span>
<span id="276"> 276</span>
<span id="277"> 277</span>
<span id="278"> 278</span>
<span id="279"> 279</span>
<span id="280"> 280</span>
<span id="281"> 281</span>
<span id="282"> 282</span>
<span id="283"> 283</span>
<span id="284"> 284</span>
<span id="285"> 285</span>
<span id="286"> 286</span>
<span id="287"> 287</span>
<span id="288"> 288</span>
<span id="289"> 289</span>
<span id="290"> 290</span>
<span id="291"> 291</span>
<span id="292"> 292</span>
<span id="293"> 293</span>
<span id="294"> 294</span>
<span id="295"> 295</span>
<span id="296"> 296</span>
<span id="297"> 297</span>
<span id="298"> 298</span>
<span id="299"> 299</span>
<span id="300"> 300</span>
<span id="301"> 301</span>
<span id="302"> 302</span>
<span id="303"> 303</span>
<span id="304"> 304</span>
<span id="305"> 305</span>
<span id="306"> 306</span>
<span id="307"> 307</span>
<span id="308"> 308</span>
<span id="309"> 309</span>
<span id="310"> 310</span>
<span id="311"> 311</span>
<span id="312"> 312</span>
<span id="313"> 313</span>
<span id="314"> 314</span>
<span id="315"> 315</span>
<span id="316"> 316</span>
<span id="317"> 317</span>
<span id="318"> 318</span>
<span id="319"> 319</span>
<span id="320"> 320</span>
<span id="321"> 321</span>
<span id="322"> 322</span>
<span id="323"> 323</span>
<span id="324"> 324</span>
<span id="325"> 325</span>
<span id="326"> 326</span>
<span id="327"> 327</span>
<span id="328"> 328</span>
<span id="329"> 329</span>
<span id="330"> 330</span>
<span id="331"> 331</span>
<span id="332"> 332</span>
<span id="333"> 333</span>
<span id="334"> 334</span>
<span id="335"> 335</span>
<span id="336"> 336</span>
<span id="337"> 337</span>
<span id="338"> 338</span>
<span id="339"> 339</span>
<span id="340"> 340</span>
<span id="341"> 341</span>
<span id="342"> 342</span>
<span id="343"> 343</span>
<span id="344"> 344</span>
<span id="345"> 345</span>
<span id="346"> 346</span>
<span id="347"> 347</span>
<span id="348"> 348</span>
<span id="349"> 349</span>
<span id="350"> 350</span>
<span id="351"> 351</span>
<span id="352"> 352</span>
<span id="353"> 353</span>
<span id="354"> 354</span>
<span id="355"> 355</span>
<span id="356"> 356</span>
<span id="357"> 357</span>
<span id="358"> 358</span>
<span id="359"> 359</span>
<span id="360"> 360</span>
<span id="361"> 361</span>
<span id="362"> 362</span>
<span id="363"> 363</span>
<span id="364"> 364</span>
<span id="365"> 365</span>
<span id="366"> 366</span>
<span id="367"> 367</span>
<span id="368"> 368</span>
<span id="369"> 369</span>
<span id="370"> 370</span>
<span id="371"> 371</span>
<span id="372"> 372</span>
<span id="373"> 373</span>
<span id="374"> 374</span>
<span id="375"> 375</span>
<span id="376"> 376</span>
<span id="377"> 377</span>
<span id="378"> 378</span>
<span id="379"> 379</span>
<span id="380"> 380</span>
<span id="381"> 381</span>
<span id="382"> 382</span>
<span id="383"> 383</span>
<span id="384"> 384</span>
<span id="385"> 385</span>
<span id="386"> 386</span>
<span id="387"> 387</span>
<span id="388"> 388</span>
<span id="389"> 389</span>
<span id="390"> 390</span>
<span id="391"> 391</span>
<span id="392"> 392</span>
<span id="393"> 393</span>
<span id="394"> 394</span>
<span id="395"> 395</span>
<span id="396"> 396</span>
<span id="397"> 397</span>
<span id="398"> 398</span>
<span id="399"> 399</span>
<span id="400"> 400</span>
<span id="401"> 401</span>
<span id="402"> 402</span>
<span id="403"> 403</span>
<span id="404"> 404</span>
<span id="405"> 405</span>
<span id="406"> 406</span>
<span id="407"> 407</span>
<span id="408"> 408</span>
<span id="409"> 409</span>
<span id="410"> 410</span>
<span id="411"> 411</span>
<span id="412"> 412</span>
<span id="413"> 413</span>
<span id="414"> 414</span>
<span id="415"> 415</span>
<span id="416"> 416</span>
<span id="417"> 417</span>
<span id="418"> 418</span>
<span id="419"> 419</span>
<span id="420"> 420</span>
<span id="421"> 421</span>
<span id="422"> 422</span>
<span id="423"> 423</span>
<span id="424"> 424</span>
<span id="425"> 425</span>
<span id="426"> 426</span>
<span id="427"> 427</span>
<span id="428"> 428</span>
<span id="429"> 429</span>
<span id="430"> 430</span>
<span id="431"> 431</span>
<span id="432"> 432</span>
<span id="433"> 433</span>
<span id="434"> 434</span>
<span id="435"> 435</span>
<span id="436"> 436</span>
<span id="437"> 437</span>
<span id="438"> 438</span>
<span id="439"> 439</span>
<span id="440"> 440</span>
<span id="441"> 441</span>
<span id="442"> 442</span>
<span id="443"> 443</span>
<span id="444"> 444</span>
<span id="445"> 445</span>
<span id="446"> 446</span>
<span id="447"> 447</span>
<span id="448"> 448</span>
<span id="449"> 449</span>
<span id="450"> 450</span>
<span id="451"> 451</span>
<span id="452"> 452</span>
<span id="453"> 453</span>
<span id="454"> 454</span>
<span id="455"> 455</span>
<span id="456"> 456</span>
<span id="457"> 457</span>
<span id="458"> 458</span>
<span id="459"> 459</span>
<span id="460"> 460</span>
<span id="461"> 461</span>
<span id="462"> 462</span>
<span id="463"> 463</span>
<span id="464"> 464</span>
<span id="465"> 465</span>
<span id="466"> 466</span>
<span id="467"> 467</span>
<span id="468"> 468</span>
<span id="469"> 469</span>
<span id="470"> 470</span>
<span id="471"> 471</span>
<span id="472"> 472</span>
<span id="473"> 473</span>
<span id="474"> 474</span>
<span id="475"> 475</span>
<span id="476"> 476</span>
<span id="477"> 477</span>
<span id="478"> 478</span>
<span id="479"> 479</span>
<span id="480"> 480</span>
<span id="481"> 481</span>
<span id="482"> 482</span>
<span id="483"> 483</span>
<span id="484"> 484</span>
<span id="485"> 485</span>
<span id="486"> 486</span>
<span id="487"> 487</span>
<span id="488"> 488</span>
<span id="489"> 489</span>
<span id="490"> 490</span>
<span id="491"> 491</span>
<span id="492"> 492</span>
<span id="493"> 493</span>
<span id="494"> 494</span>
<span id="495"> 495</span>
<span id="496"> 496</span>
<span id="497"> 497</span>
<span id="498"> 498</span>
<span id="499"> 499</span>
<span id="500"> 500</span>
<span id="501"> 501</span>
<span id="502"> 502</span>
<span id="503"> 503</span>
<span id="504"> 504</span>
<span id="505"> 505</span>
<span id="506"> 506</span>
<span id="507"> 507</span>
<span id="508"> 508</span>
<span id="509"> 509</span>
<span id="510"> 510</span>
<span id="511"> 511</span>
<span id="512"> 512</span>
<span id="513"> 513</span>
<span id="514"> 514</span>
<span id="515"> 515</span>
<span id="516"> 516</span>
<span id="517"> 517</span>
<span id="518"> 518</span>
<span id="519"> 519</span>
<span id="520"> 520</span>
<span id="521"> 521</span>
<span id="522"> 522</span>
<span id="523"> 523</span>
<span id="524"> 524</span>
<span id="525"> 525</span>
<span id="526"> 526</span>
<span id="527"> 527</span>
<span id="528"> 528</span>
<span id="529"> 529</span>
<span id="530"> 530</span>
<span id="531"> 531</span>
<span id="532"> 532</span>
<span id="533"> 533</span>
<span id="534"> 534</span>
<span id="535"> 535</span>
<span id="536"> 536</span>
<span id="537"> 537</span>
<span id="538"> 538</span>
<span id="539"> 539</span>
<span id="540"> 540</span>
<span id="541"> 541</span>
<span id="542"> 542</span>
<span id="543"> 543</span>
<span id="544"> 544</span>
<span id="545"> 545</span>
<span id="546"> 546</span>
<span id="547"> 547</span>
<span id="548"> 548</span>
<span id="549"> 549</span>
<span id="550"> 550</span>
<span id="551"> 551</span>
<span id="552"> 552</span>
<span id="553"> 553</span>
<span id="554"> 554</span>
<span id="555"> 555</span>
<span id="556"> 556</span>
<span id="557"> 557</span>
<span id="558"> 558</span>
<span id="559"> 559</span>
<span id="560"> 560</span>
<span id="561"> 561</span>
<span id="562"> 562</span>
<span id="563"> 563</span>
<span id="564"> 564</span>
<span id="565"> 565</span>
<span id="566"> 566</span>
<span id="567"> 567</span>
<span id="568"> 568</span>
<span id="569"> 569</span>
<span id="570"> 570</span>
<span id="571"> 571</span>
<span id="572"> 572</span>
<span id="573"> 573</span>
<span id="574"> 574</span>
<span id="575"> 575</span>
<span id="576"> 576</span>
<span id="577"> 577</span>
<span id="578"> 578</span>
<span id="579"> 579</span>
<span id="580"> 580</span>
<span id="581"> 581</span>
<span id="582"> 582</span>
<span id="583"> 583</span>
<span id="584"> 584</span>
<span id="585"> 585</span>
<span id="586"> 586</span>
<span id="587"> 587</span>
<span id="588"> 588</span>
<span id="589"> 589</span>
<span id="590"> 590</span>
<span id="591"> 591</span>
<span id="592"> 592</span>
<span id="593"> 593</span>
<span id="594"> 594</span>
<span id="595"> 595</span>
<span id="596"> 596</span>
<span id="597"> 597</span>
<span id="598"> 598</span>
<span id="599"> 599</span>
<span id="600"> 600</span>
<span id="601"> 601</span>
<span id="602"> 602</span>
<span id="603"> 603</span>
<span id="604"> 604</span>
<span id="605"> 605</span>
<span id="606"> 606</span>
<span id="607"> 607</span>
<span id="608"> 608</span>
<span id="609"> 609</span>
<span id="610"> 610</span>
<span id="611"> 611</span>
<span id="612"> 612</span>
<span id="613"> 613</span>
<span id="614"> 614</span>
<span id="615"> 615</span>
<span id="616"> 616</span>
<span id="617"> 617</span>
<span id="618"> 618</span>
<span id="619"> 619</span>
<span id="620"> 620</span>
<span id="621"> 621</span>
<span id="622"> 622</span>
<span id="623"> 623</span>
<span id="624"> 624</span>
<span id="625"> 625</span>
<span id="626"> 626</span>
<span id="627"> 627</span>
<span id="628"> 628</span>
<span id="629"> 629</span>
<span id="630"> 630</span>
<span id="631"> 631</span>
<span id="632"> 632</span>
<span id="633"> 633</span>
<span id="634"> 634</span>
<span id="635"> 635</span>
<span id="636"> 636</span>
<span id="637"> 637</span>
<span id="638"> 638</span>
<span id="639"> 639</span>
<span id="640"> 640</span>
<span id="641"> 641</span>
<span id="642"> 642</span>
<span id="643"> 643</span>
<span id="644"> 644</span>
<span id="645"> 645</span>
<span id="646"> 646</span>
<span id="647"> 647</span>
<span id="648"> 648</span>
<span id="649"> 649</span>
<span id="650"> 650</span>
<span id="651"> 651</span>
<span id="652"> 652</span>
<span id="653"> 653</span>
<span id="654"> 654</span>
<span id="655"> 655</span>
<span id="656"> 656</span>
<span id="657"> 657</span>
<span id="658"> 658</span>
<span id="659"> 659</span>
<span id="660"> 660</span>
<span id="661"> 661</span>
<span id="662"> 662</span>
<span id="663"> 663</span>
<span id="664"> 664</span>
<span id="665"> 665</span>
<span id="666"> 666</span>
<span id="667"> 667</span>
<span id="668"> 668</span>
<span id="669"> 669</span>
<span id="670"> 670</span>
<span id="671"> 671</span>
<span id="672"> 672</span>
<span id="673"> 673</span>
<span id="674"> 674</span>
<span id="675"> 675</span>
<span id="676"> 676</span>
<span id="677"> 677</span>
<span id="678"> 678</span>
<span id="679"> 679</span>
<span id="680"> 680</span>
<span id="681"> 681</span>
<span id="682"> 682</span>
<span id="683"> 683</span>
<span id="684"> 684</span>
<span id="685"> 685</span>
<span id="686"> 686</span>
<span id="687"> 687</span>
<span id="688"> 688</span>
<span id="689"> 689</span>
<span id="690"> 690</span>
<span id="691"> 691</span>
<span id="692"> 692</span>
<span id="693"> 693</span>
<span id="694"> 694</span>
<span id="695"> 695</span>
<span id="696"> 696</span>
<span id="697"> 697</span>
<span id="698"> 698</span>
<span id="699"> 699</span>
<span id="700"> 700</span>
<span id="701"> 701</span>
<span id="702"> 702</span>
<span id="703"> 703</span>
<span id="704"> 704</span>
<span id="705"> 705</span>
<span id="706"> 706</span>
<span id="707"> 707</span>
<span id="708"> 708</span>
<span id="709"> 709</span>
<span id="710"> 710</span>
<span id="711"> 711</span>
<span id="712"> 712</span>
<span id="713"> 713</span>
<span id="714"> 714</span>
<span id="715"> 715</span>
<span id="716"> 716</span>
<span id="717"> 717</span>
<span id="718"> 718</span>
<span id="719"> 719</span>
<span id="720"> 720</span>
<span id="721"> 721</span>
<span id="722"> 722</span>
<span id="723"> 723</span>
<span id="724"> 724</span>
<span id="725"> 725</span>
<span id="726"> 726</span>
<span id="727"> 727</span>
<span id="728"> 728</span>
<span id="729"> 729</span>
<span id="730"> 730</span>
<span id="731"> 731</span>
<span id="732"> 732</span>
<span id="733"> 733</span>
<span id="734"> 734</span>
<span id="735"> 735</span>
<span id="736"> 736</span>
<span id="737"> 737</span>
<span id="738"> 738</span>
<span id="739"> 739</span>
<span id="740"> 740</span>
<span id="741"> 741</span>
<span id="742"> 742</span>
<span id="743"> 743</span>
<span id="744"> 744</span>
<span id="745"> 745</span>
<span id="746"> 746</span>
<span id="747"> 747</span>
<span id="748"> 748</span>
<span id="749"> 749</span>
<span id="750"> 750</span>
<span id="751"> 751</span>
<span id="752"> 752</span>
<span id="753"> 753</span>
<span id="754"> 754</span>
<span id="755"> 755</span>
<span id="756"> 756</span>
<span id="757"> 757</span>
<span id="758"> 758</span>
<span id="759"> 759</span>
<span id="760"> 760</span>
<span id="761"> 761</span>
<span id="762"> 762</span>
<span id="763"> 763</span>
<span id="764"> 764</span>
<span id="765"> 765</span>
<span id="766"> 766</span>
<span id="767"> 767</span>
<span id="768"> 768</span>
<span id="769"> 769</span>
<span id="770"> 770</span>
<span id="771"> 771</span>
<span id="772"> 772</span>
<span id="773"> 773</span>
<span id="774"> 774</span>
<span id="775"> 775</span>
<span id="776"> 776</span>
<span id="777"> 777</span>
<span id="778"> 778</span>
<span id="779"> 779</span>
<span id="780"> 780</span>
<span id="781"> 781</span>
<span id="782"> 782</span>
<span id="783"> 783</span>
<span id="784"> 784</span>
<span id="785"> 785</span>
<span id="786"> 786</span>
<span id="787"> 787</span>
<span id="788"> 788</span>
<span id="789"> 789</span>
<span id="790"> 790</span>
<span id="791"> 791</span>
<span id="792"> 792</span>
<span id="793"> 793</span>
<span id="794"> 794</span>
<span id="795"> 795</span>
<span id="796"> 796</span>
<span id="797"> 797</span>
<span id="798"> 798</span>
<span id="799"> 799</span>
<span id="800"> 800</span>
<span id="801"> 801</span>
<span id="802"> 802</span>
<span id="803"> 803</span>
<span id="804"> 804</span>
<span id="805"> 805</span>
<span id="806"> 806</span>
<span id="807"> 807</span>
<span id="808"> 808</span>
<span id="809"> 809</span>
<span id="810"> 810</span>
<span id="811"> 811</span>
<span id="812"> 812</span>
<span id="813"> 813</span>
<span id="814"> 814</span>
<span id="815"> 815</span>
<span id="816"> 816</span>
<span id="817"> 817</span>
<span id="818"> 818</span>
<span id="819"> 819</span>
<span id="820"> 820</span>
<span id="821"> 821</span>
<span id="822"> 822</span>
<span id="823"> 823</span>
<span id="824"> 824</span>
<span id="825"> 825</span>
<span id="826"> 826</span>
<span id="827"> 827</span>
<span id="828"> 828</span>
<span id="829"> 829</span>
<span id="830"> 830</span>
<span id="831"> 831</span>
<span id="832"> 832</span>
<span id="833"> 833</span>
<span id="834"> 834</span>
<span id="835"> 835</span>
<span id="836"> 836</span>
<span id="837"> 837</span>
<span id="838"> 838</span>
<span id="839"> 839</span>
<span id="840"> 840</span>
<span id="841"> 841</span>
<span id="842"> 842</span>
<span id="843"> 843</span>
<span id="844"> 844</span>
<span id="845"> 845</span>
<span id="846"> 846</span>
<span id="847"> 847</span>
<span id="848"> 848</span>
<span id="849"> 849</span>
<span id="850"> 850</span>
<span id="851"> 851</span>
<span id="852"> 852</span>
<span id="853"> 853</span>
<span id="854"> 854</span>
<span id="855"> 855</span>
<span id="856"> 856</span>
<span id="857"> 857</span>
<span id="858"> 858</span>
<span id="859"> 859</span>
<span id="860"> 860</span>
<span id="861"> 861</span>
<span id="862"> 862</span>
<span id="863"> 863</span>
<span id="864"> 864</span>
<span id="865"> 865</span>
<span id="866"> 866</span>
<span id="867"> 867</span>
<span id="868"> 868</span>
<span id="869"> 869</span>
<span id="870"> 870</span>
<span id="871"> 871</span>
<span id="872"> 872</span>
<span id="873"> 873</span>
<span id="874"> 874</span>
<span id="875"> 875</span>
<span id="876"> 876</span>
<span id="877"> 877</span>
<span id="878"> 878</span>
<span id="879"> 879</span>
<span id="880"> 880</span>
<span id="881"> 881</span>
<span id="882"> 882</span>
<span id="883"> 883</span>
<span id="884"> 884</span>
<span id="885"> 885</span>
<span id="886"> 886</span>
<span id="887"> 887</span>
<span id="888"> 888</span>
<span id="889"> 889</span>
<span id="890"> 890</span>
<span id="891"> 891</span>
<span id="892"> 892</span>
<span id="893"> 893</span>
<span id="894"> 894</span>
<span id="895"> 895</span>
<span id="896"> 896</span>
<span id="897"> 897</span>
<span id="898"> 898</span>
<span id="899"> 899</span>
<span id="900"> 900</span>
<span id="901"> 901</span>
<span id="902"> 902</span>
<span id="903"> 903</span>
<span id="904"> 904</span>
<span id="905"> 905</span>
<span id="906"> 906</span>
<span id="907"> 907</span>
<span id="908"> 908</span>
<span id="909"> 909</span>
<span id="910"> 910</span>
<span id="911"> 911</span>
<span id="912"> 912</span>
<span id="913"> 913</span>
<span id="914"> 914</span>
<span id="915"> 915</span>
<span id="916"> 916</span>
<span id="917"> 917</span>
<span id="918"> 918</span>
<span id="919"> 919</span>
<span id="920"> 920</span>
<span id="921"> 921</span>
<span id="922"> 922</span>
<span id="923"> 923</span>
<span id="924"> 924</span>
<span id="925"> 925</span>
<span id="926"> 926</span>
<span id="927"> 927</span>
<span id="928"> 928</span>
<span id="929"> 929</span>
<span id="930"> 930</span>
<span id="931"> 931</span>
<span id="932"> 932</span>
<span id="933"> 933</span>
<span id="934"> 934</span>
<span id="935"> 935</span>
<span id="936"> 936</span>
<span id="937"> 937</span>
<span id="938"> 938</span>
<span id="939"> 939</span>
<span id="940"> 940</span>
<span id="941"> 941</span>
<span id="942"> 942</span>
<span id="943"> 943</span>
<span id="944"> 944</span>
<span id="945"> 945</span>
<span id="946"> 946</span>
<span id="947"> 947</span>
<span id="948"> 948</span>
<span id="949"> 949</span>
<span id="950"> 950</span>
<span id="951"> 951</span>
<span id="952"> 952</span>
<span id="953"> 953</span>
<span id="954"> 954</span>
<span id="955"> 955</span>
<span id="956"> 956</span>
<span id="957"> 957</span>
<span id="958"> 958</span>
<span id="959"> 959</span>
<span id="960"> 960</span>
<span id="961"> 961</span>
<span id="962"> 962</span>
<span id="963"> 963</span>
<span id="964"> 964</span>
<span id="965"> 965</span>
<span id="966"> 966</span>
<span id="967"> 967</span>
<span id="968"> 968</span>
<span id="969"> 969</span>
<span id="970"> 970</span>
<span id="971"> 971</span>
<span id="972"> 972</span>
<span id="973"> 973</span>
<span id="974"> 974</span>
<span id="975"> 975</span>
<span id="976"> 976</span>
<span id="977"> 977</span>
<span id="978"> 978</span>
<span id="979"> 979</span>
<span id="980"> 980</span>
<span id="981"> 981</span>
<span id="982"> 982</span>
<span id="983"> 983</span>
<span id="984"> 984</span>
<span id="985"> 985</span>
<span id="986"> 986</span>
<span id="987"> 987</span>
<span id="988"> 988</span>
<span id="989"> 989</span>
<span id="990"> 990</span>
<span id="991"> 991</span>
<span id="992"> 992</span>
<span id="993"> 993</span>
<span id="994"> 994</span>
<span id="995"> 995</span>
<span id="996"> 996</span>
<span id="997"> 997</span>
<span id="998"> 998</span>
<span id="999"> 999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
<span id="1021">1021</span>
<span id="1022">1022</span>
<span id="1023">1023</span>
<span id="1024">1024</span>
<span id="1025">1025</span>
<span id="1026">1026</span>
<span id="1027">1027</span>
<span id="1028">1028</span>
<span id="1029">1029</span>
<span id="1030">1030</span>
<span id="1031">1031</span>
<span id="1032">1032</span>
<span id="1033">1033</span>
<span id="1034">1034</span>
<span id="1035">1035</span>
<span id="1036">1036</span>
<span id="1037">1037</span>
<span id="1038">1038</span>
<span id="1039">1039</span>
<span id="1040">1040</span>
<span id="1041">1041</span>
<span id="1042">1042</span>
<span id="1043">1043</span>
<span id="1044">1044</span>
<span id="1045">1045</span>
<span id="1046">1046</span>
<span id="1047">1047</span>
<span id="1048">1048</span>
<span id="1049">1049</span>
<span id="1050">1050</span>
<span id="1051">1051</span>
<span id="1052">1052</span>
<span id="1053">1053</span>
<span id="1054">1054</span>
<span id="1055">1055</span>
<span id="1056">1056</span>
<span id="1057">1057</span>
<span id="1058">1058</span>
<span id="1059">1059</span>
<span id="1060">1060</span>
<span id="1061">1061</span>
<span id="1062">1062</span>
<span id="1063">1063</span>
<span id="1064">1064</span>
<span id="1065">1065</span>
<span id="1066">1066</span>
<span id="1067">1067</span>
<span id="1068">1068</span>
<span id="1069">1069</span>
<span id="1070">1070</span>
<span id="1071">1071</span>
<span id="1072">1072</span>
<span id="1073">1073</span>
<span id="1074">1074</span>
<span id="1075">1075</span>
<span id="1076">1076</span>
<span id="1077">1077</span>
<span id="1078">1078</span>
<span id="1079">1079</span>
<span id="1080">1080</span>
<span id="1081">1081</span>
<span id="1082">1082</span>
<span id="1083">1083</span>
<span id="1084">1084</span>
<span id="1085">1085</span>
<span id="1086">1086</span>
<span id="1087">1087</span>
<span id="1088">1088</span>
<span id="1089">1089</span>
<span id="1090">1090</span>
<span id="1091">1091</span>
<span id="1092">1092</span>
<span id="1093">1093</span>
<span id="1094">1094</span>
<span id="1095">1095</span>
<span id="1096">1096</span>
<span id="1097">1097</span>
<span id="1098">1098</span>
<span id="1099">1099</span>
<span id="1100">1100</span>
<span id="1101">1101</span>
<span id="1102">1102</span>
<span id="1103">1103</span>
<span id="1104">1104</span>
<span id="1105">1105</span>
<span id="1106">1106</span>
<span id="1107">1107</span>
<span id="1108">1108</span>
<span id="1109">1109</span>
<span id="1110">1110</span>
<span id="1111">1111</span>
<span id="1112">1112</span>
<span id="1113">1113</span>
<span id="1114">1114</span>
<span id="1115">1115</span>
<span id="1116">1116</span>
<span id="1117">1117</span>
<span id="1118">1118</span>
<span id="1119">1119</span>
<span id="1120">1120</span>
<span id="1121">1121</span>
<span id="1122">1122</span>
<span id="1123">1123</span>
<span id="1124">1124</span>
<span id="1125">1125</span>
<span id="1126">1126</span>
<span id="1127">1127</span>
<span id="1128">1128</span>
<span id="1129">1129</span>
<span id="1130">1130</span>
<span id="1131">1131</span>
<span id="1132">1132</span>
<span id="1133">1133</span>
<span id="1134">1134</span>
<span id="1135">1135</span>
<span id="1136">1136</span>
<span id="1137">1137</span>
<span id="1138">1138</span>
<span id="1139">1139</span>
<span id="1140">1140</span>
<span id="1141">1141</span>
<span id="1142">1142</span>
<span id="1143">1143</span>
<span id="1144">1144</span>
<span id="1145">1145</span>
<span id="1146">1146</span>
<span id="1147">1147</span>
<span id="1148">1148</span>
<span id="1149">1149</span>
<span id="1150">1150</span>
<span id="1151">1151</span>
<span id="1152">1152</span>
<span id="1153">1153</span>
<span id="1154">1154</span>
<span id="1155">1155</span>
<span id="1156">1156</span>
<span id="1157">1157</span>
<span id="1158">1158</span>
<span id="1159">1159</span>
<span id="1160">1160</span>
<span id="1161">1161</span>
<span id="1162">1162</span>
<span id="1163">1163</span>
<span id="1164">1164</span>
<span id="1165">1165</span>
<span id="1166">1166</span>
<span id="1167">1167</span>
<span id="1168">1168</span>
<span id="1169">1169</span>
<span id="1170">1170</span>
<span id="1171">1171</span>
<span id="1172">1172</span>
<span id="1173">1173</span>
<span id="1174">1174</span>
<span id="1175">1175</span>
<span id="1176">1176</span>
<span id="1177">1177</span>
<span id="1178">1178</span>
<span id="1179">1179</span>
<span id="1180">1180</span>
<span id="1181">1181</span>
<span id="1182">1182</span>
<span id="1183">1183</span>
<span id="1184">1184</span>
<span id="1185">1185</span>
<span id="1186">1186</span>
<span id="1187">1187</span>
<span id="1188">1188</span>
<span id="1189">1189</span>
<span id="1190">1190</span>
<span id="1191">1191</span>
<span id="1192">1192</span>
<span id="1193">1193</span>
<span id="1194">1194</span>
<span id="1195">1195</span>
<span id="1196">1196</span>
<span id="1197">1197</span>
<span id="1198">1198</span>
<span id="1199">1199</span>
<span id="1200">1200</span>
<span id="1201">1201</span>
<span id="1202">1202</span>
<span id="1203">1203</span>
<span id="1204">1204</span>
<span id="1205">1205</span>
<span id="1206">1206</span>
<span id="1207">1207</span>
<span id="1208">1208</span>
<span id="1209">1209</span>
<span id="1210">1210</span>
<span id="1211">1211</span>
<span id="1212">1212</span>
<span id="1213">1213</span>
<span id="1214">1214</span>
<span id="1215">1215</span>
<span id="1216">1216</span>
<span id="1217">1217</span>
<span id="1218">1218</span>
<span id="1219">1219</span>
<span id="1220">1220</span>
<span id="1221">1221</span>
<span id="1222">1222</span>
<span id="1223">1223</span>
<span id="1224">1224</span>
<span id="1225">1225</span>
<span id="1226">1226</span>
<span id="1227">1227</span>
<span id="1228">1228</span>
<span id="1229">1229</span>
<span id="1230">1230</span>
<span id="1231">1231</span>
<span id="1232">1232</span>
<span id="1233">1233</span>
<span id="1234">1234</span>
<span id="1235">1235</span>
<span id="1236">1236</span>
<span id="1237">1237</span>
<span id="1238">1238</span>
<span id="1239">1239</span>
<span id="1240">1240</span>
<span id="1241">1241</span>
<span id="1242">1242</span>
<span id="1243">1243</span>
<span id="1244">1244</span>
<span id="1245">1245</span>
<span id="1246">1246</span>
<span id="1247">1247</span>
<span id="1248">1248</span>
<span id="1249">1249</span>
<span id="1250">1250</span>
<span id="1251">1251</span>
<span id="1252">1252</span>
<span id="1253">1253</span>
<span id="1254">1254</span>
<span id="1255">1255</span>
<span id="1256">1256</span>
<span id="1257">1257</span>
<span id="1258">1258</span>
<span id="1259">1259</span>
<span id="1260">1260</span>
<span id="1261">1261</span>
<span id="1262">1262</span>
<span id="1263">1263</span>
<span id="1264">1264</span>
<span id="1265">1265</span>
<span id="1266">1266</span>
<span id="1267">1267</span>
<span id="1268">1268</span>
<span id="1269">1269</span>
<span id="1270">1270</span>
<span id="1271">1271</span>
<span id="1272">1272</span>
<span id="1273">1273</span>
<span id="1274">1274</span>
<span id="1275">1275</span>
<span id="1276">1276</span>
<span id="1277">1277</span>
<span id="1278">1278</span>
<span id="1279">1279</span>
<span id="1280">1280</span>
<span id="1281">1281</span>
<span id="1282">1282</span>
<span id="1283">1283</span>
<span id="1284">1284</span>
<span id="1285">1285</span>
<span id="1286">1286</span>
<span id="1287">1287</span>
<span id="1288">1288</span>
<span id="1289">1289</span>
<span id="1290">1290</span>
<span id="1291">1291</span>
<span id="1292">1292</span>
<span id="1293">1293</span>
<span id="1294">1294</span>
<span id="1295">1295</span>
<span id="1296">1296</span>
<span id="1297">1297</span>
<span id="1298">1298</span>
<span id="1299">1299</span>
<span id="1300">1300</span>
<span id="1301">1301</span>
<span id="1302">1302</span>
<span id="1303">1303</span>
<span id="1304">1304</span>
<span id="1305">1305</span>
<span id="1306">1306</span>
<span id="1307">1307</span>
<span id="1308">1308</span>
<span id="1309">1309</span>
<span id="1310">1310</span>
<span id="1311">1311</span>
<span id="1312">1312</span>
<span id="1313">1313</span>
<span id="1314">1314</span>
<span id="1315">1315</span>
<span id="1316">1316</span>
<span id="1317">1317</span>
<span id="1318">1318</span>
<span id="1319">1319</span>
<span id="1320">1320</span>
<span id="1321">1321</span>
<span id="1322">1322</span>
<span id="1323">1323</span>
<span id="1324">1324</span>
<span id="1325">1325</span>
<span id="1326">1326</span>
<span id="1327">1327</span>
<span id="1328">1328</span>
<span id="1329">1329</span>
<span id="1330">1330</span>
<span id="1331">1331</span>
<span id="1332">1332</span>
<span id="1333">1333</span>
<span id="1334">1334</span>
<span id="1335">1335</span>
<span id="1336">1336</span>
<span id="1337">1337</span>
<span id="1338">1338</span>
<span id="1339">1339</span>
<span id="1340">1340</span>
<span id="1341">1341</span>
<span id="1342">1342</span>
<span id="1343">1343</span>
<span id="1344">1344</span>
<span id="1345">1345</span>
<span id="1346">1346</span>
<span id="1347">1347</span>
<span id="1348">1348</span>
<span id="1349">1349</span>
<span id="1350">1350</span>
<span id="1351">1351</span>
<span id="1352">1352</span>
<span id="1353">1353</span>
<span id="1354">1354</span>
<span id="1355">1355</span>
<span id="1356">1356</span>
<span id="1357">1357</span>
<span id="1358">1358</span>
<span id="1359">1359</span>
<span id="1360">1360</span>
<span id="1361">1361</span>
<span id="1362">1362</span>
<span id="1363">1363</span>
<span id="1364">1364</span>
<span id="1365">1365</span>
<span id="1366">1366</span>
<span id="1367">1367</span>
<span id="1368">1368</span>
<span id="1369">1369</span>
<span id="1370">1370</span>
<span id="1371">1371</span>
<span id="1372">1372</span>
<span id="1373">1373</span>
<span id="1374">1374</span>
<span id="1375">1375</span>
<span id="1376">1376</span>
<span id="1377">1377</span>
<span id="1378">1378</span>
<span id="1379">1379</span>
<span id="1380">1380</span>
<span id="1381">1381</span>
<span id="1382">1382</span>
<span id="1383">1383</span>
<span id="1384">1384</span>
<span id="1385">1385</span>
<span id="1386">1386</span>
<span id="1387">1387</span>
<span id="1388">1388</span>
<span id="1389">1389</span>
<span id="1390">1390</span>
<span id="1391">1391</span>
<span id="1392">1392</span>
<span id="1393">1393</span>
<span id="1394">1394</span>
<span id="1395">1395</span>
<span id="1396">1396</span>
<span id="1397">1397</span>
<span id="1398">1398</span>
<span id="1399">1399</span>
<span id="1400">1400</span>
<span id="1401">1401</span>
<span id="1402">1402</span>
<span id="1403">1403</span>
<span id="1404">1404</span>
<span id="1405">1405</span>
<span id="1406">1406</span>
<span id="1407">1407</span>
<span id="1408">1408</span>
<span id="1409">1409</span>
<span id="1410">1410</span>
<span id="1411">1411</span>
<span id="1412">1412</span>
<span id="1413">1413</span>
<span id="1414">1414</span>
<span id="1415">1415</span>
<span id="1416">1416</span>
<span id="1417">1417</span>
<span id="1418">1418</span>
<span id="1419">1419</span>
<span id="1420">1420</span>
<span id="1421">1421</span>
<span id="1422">1422</span>
<span id="1423">1423</span>
<span id="1424">1424</span>
<span id="1425">1425</span>
<span id="1426">1426</span>
<span id="1427">1427</span>
<span id="1428">1428</span>
<span id="1429">1429</span>
<span id="1430">1430</span>
<span id="1431">1431</span>
<span id="1432">1432</span>
<span id="1433">1433</span>
<span id="1434">1434</span>
<span id="1435">1435</span>
<span id="1436">1436</span>
<span id="1437">1437</span>
<span id="1438">1438</span>
<span id="1439">1439</span>
<span id="1440">1440</span>
<span id="1441">1441</span>
<span id="1442">1442</span>
<span id="1443">1443</span>
<span id="1444">1444</span>
<span id="1445">1445</span>
<span id="1446">1446</span>
<span id="1447">1447</span>
<span id="1448">1448</span>
<span id="1449">1449</span>
<span id="1450">1450</span>
<span id="1451">1451</span>
<span id="1452">1452</span>
<span id="1453">1453</span>
<span id="1454">1454</span>
<span id="1455">1455</span>
<span id="1456">1456</span>
<span id="1457">1457</span>
<span id="1458">1458</span>
<span id="1459">1459</span>
<span id="1460">1460</span>
<span id="1461">1461</span>
<span id="1462">1462</span>
<span id="1463">1463</span>
<span id="1464">1464</span>
<span id="1465">1465</span>
<span id="1466">1466</span>
<span id="1467">1467</span>
<span id="1468">1468</span>
<span id="1469">1469</span>
<span id="1470">1470</span>
<span id="1471">1471</span>
<span id="1472">1472</span>
<span id="1473">1473</span>
<span id="1474">1474</span>
<span id="1475">1475</span>
<span id="1476">1476</span>
<span id="1477">1477</span>
<span id="1478">1478</span>
<span id="1479">1479</span>
<span id="1480">1480</span>
<span id="1481">1481</span>
<span id="1482">1482</span>
<span id="1483">1483</span>
<span id="1484">1484</span>
<span id="1485">1485</span>
<span id="1486">1486</span>
<span id="1487">1487</span>
<span id="1488">1488</span>
<span id="1489">1489</span>
<span id="1490">1490</span>
<span id="1491">1491</span>
<span id="1492">1492</span>
<span id="1493">1493</span>
<span id="1494">1494</span>
<span id="1495">1495</span>
<span id="1496">1496</span>
<span id="1497">1497</span>
<span id="1498">1498</span>
<span id="1499">1499</span>
<span id="1500">1500</span>
<span id="1501">1501</span>
<span id="1502">1502</span>
<span id="1503">1503</span>
<span id="1504">1504</span>
<span id="1505">1505</span>
<span id="1506">1506</span>
<span id="1507">1507</span>
<span id="1508">1508</span>
<span id="1509">1509</span>
<span id="1510">1510</span>
<span id="1511">1511</span>
<span id="1512">1512</span>
<span id="1513">1513</span>
<span id="1514">1514</span>
<span id="1515">1515</span>
<span id="1516">1516</span>
<span id="1517">1517</span>
<span id="1518">1518</span>
<span id="1519">1519</span>
<span id="1520">1520</span>
<span id="1521">1521</span>
<span id="1522">1522</span>
<span id="1523">1523</span>
<span id="1524">1524</span>
<span id="1525">1525</span>
<span id="1526">1526</span>
<span id="1527">1527</span>
<span id="1528">1528</span>
<span id="1529">1529</span>
<span id="1530">1530</span>
<span id="1531">1531</span>
<span id="1532">1532</span>
<span id="1533">1533</span>
<span id="1534">1534</span>
<span id="1535">1535</span>
<span id="1536">1536</span>
<span id="1537">1537</span>
<span id="1538">1538</span>
<span id="1539">1539</span>
<span id="1540">1540</span>
<span id="1541">1541</span>
<span id="1542">1542</span>
<span id="1543">1543</span>
<span id="1544">1544</span>
<span id="1545">1545</span>
<span id="1546">1546</span>
<span id="1547">1547</span>
<span id="1548">1548</span>
<span id="1549">1549</span>
<span id="1550">1550</span>
<span id="1551">1551</span>
<span id="1552">1552</span>
<span id="1553">1553</span>
<span id="1554">1554</span>
<span id="1555">1555</span>
<span id="1556">1556</span>
<span id="1557">1557</span>
<span id="1558">1558</span>
<span id="1559">1559</span>
<span id="1560">1560</span>
<span id="1561">1561</span>
<span id="1562">1562</span>
<span id="1563">1563</span>
<span id="1564">1564</span>
<span id="1565">1565</span>
<span id="1566">1566</span>
<span id="1567">1567</span>
<span id="1568">1568</span>
<span id="1569">1569</span>
<span id="1570">1570</span>
<span id="1571">1571</span>
<span id="1572">1572</span>
<span id="1573">1573</span>
<span id="1574">1574</span>
<span id="1575">1575</span>
<span id="1576">1576</span>
<span id="1577">1577</span>
<span id="1578">1578</span>
<span id="1579">1579</span>
<span id="1580">1580</span>
<span id="1581">1581</span>
<span id="1582">1582</span>
<span id="1583">1583</span>
<span id="1584">1584</span>
<span id="1585">1585</span>
<span id="1586">1586</span>
<span id="1587">1587</span>
<span id="1588">1588</span>
<span id="1589">1589</span>
<span id="1590">1590</span>
<span id="1591">1591</span>
<span id="1592">1592</span>
<span id="1593">1593</span>
<span id="1594">1594</span>
<span id="1595">1595</span>
<span id="1596">1596</span>
<span id="1597">1597</span>
<span id="1598">1598</span>
<span id="1599">1599</span>
<span id="1600">1600</span>
<span id="1601">1601</span>
<span id="1602">1602</span>
<span id="1603">1603</span>
<span id="1604">1604</span>
<span id="1605">1605</span>
<span id="1606">1606</span>
<span id="1607">1607</span>
<span id="1608">1608</span>
<span id="1609">1609</span>
<span id="1610">1610</span>
<span id="1611">1611</span>
<span id="1612">1612</span>
<span id="1613">1613</span>
<span id="1614">1614</span>
<span id="1615">1615</span>
<span id="1616">1616</span>
<span id="1617">1617</span>
<span id="1618">1618</span>
<span id="1619">1619</span>
<span id="1620">1620</span>
<span id="1621">1621</span>
<span id="1622">1622</span>
<span id="1623">1623</span>
<span id="1624">1624</span>
<span id="1625">1625</span>
<span id="1626">1626</span>
<span id="1627">1627</span>
<span id="1628">1628</span>
<span id="1629">1629</span>
<span id="1630">1630</span>
<span id="1631">1631</span>
<span id="1632">1632</span>
<span id="1633">1633</span>
<span id="1634">1634</span>
<span id="1635">1635</span>
<span id="1636">1636</span>
<span id="1637">1637</span>
<span id="1638">1638</span>
<span id="1639">1639</span>
<span id="1640">1640</span>
<span id="1641">1641</span>
<span id="1642">1642</span>
<span id="1643">1643</span>
<span id="1644">1644</span>
<span id="1645">1645</span>
<span id="1646">1646</span>
<span id="1647">1647</span>
<span id="1648">1648</span>
<span id="1649">1649</span>
<span id="1650">1650</span>
<span id="1651">1651</span>
<span id="1652">1652</span>
<span id="1653">1653</span>
<span id="1654">1654</span>
<span id="1655">1655</span>
<span id="1656">1656</span>
<span id="1657">1657</span>
<span id="1658">1658</span>
<span id="1659">1659</span>
<span id="1660">1660</span>
<span id="1661">1661</span>
<span id="1662">1662</span>
<span id="1663">1663</span>
<span id="1664">1664</span>
<span id="1665">1665</span>
<span id="1666">1666</span>
<span id="1667">1667</span>
<span id="1668">1668</span>
<span id="1669">1669</span>
<span id="1670">1670</span>
<span id="1671">1671</span>
<span id="1672">1672</span>
<span id="1673">1673</span>
<span id="1674">1674</span>
<span id="1675">1675</span>
<span id="1676">1676</span>
<span id="1677">1677</span>
<span id="1678">1678</span>
<span id="1679">1679</span>
<span id="1680">1680</span>
<span id="1681">1681</span>
<span id="1682">1682</span>
<span id="1683">1683</span>
<span id="1684">1684</span>
<span id="1685">1685</span>
<span id="1686">1686</span>
<span id="1687">1687</span>
<span id="1688">1688</span>
<span id="1689">1689</span>
<span id="1690">1690</span>
<span id="1691">1691</span>
<span id="1692">1692</span>
<span id="1693">1693</span>
<span id="1694">1694</span>
<span id="1695">1695</span>
<span id="1696">1696</span>
<span id="1697">1697</span>
<span id="1698">1698</span>
<span id="1699">1699</span>
<span id="1700">1700</span>
<span id="1701">1701</span>
<span id="1702">1702</span>
<span id="1703">1703</span>
<span id="1704">1704</span>
<span id="1705">1705</span>
<span id="1706">1706</span>
<span id="1707">1707</span>
<span id="1708">1708</span>
<span id="1709">1709</span>
<span id="1710">1710</span>
<span id="1711">1711</span>
<span id="1712">1712</span>
<span id="1713">1713</span>
<span id="1714">1714</span>
<span id="1715">1715</span>
<span id="1716">1716</span>
<span id="1717">1717</span>
<span id="1718">1718</span>
<span id="1719">1719</span>
<span id="1720">1720</span>
<span id="1721">1721</span>
<span id="1722">1722</span>
<span id="1723">1723</span>
<span id="1724">1724</span>
<span id="1725">1725</span>
<span id="1726">1726</span>
<span id="1727">1727</span>
<span id="1728">1728</span>
<span id="1729">1729</span>
<span id="1730">1730</span>
<span id="1731">1731</span>
<span id="1732">1732</span>
<span id="1733">1733</span>
<span id="1734">1734</span>
<span id="1735">1735</span>
<span id="1736">1736</span>
<span id="1737">1737</span>
<span id="1738">1738</span>
<span id="1739">1739</span>
<span id="1740">1740</span>
<span id="1741">1741</span>
<span id="1742">1742</span>
<span id="1743">1743</span>
<span id="1744">1744</span>
<span id="1745">1745</span>
<span id="1746">1746</span>
<span id="1747">1747</span>
<span id="1748">1748</span>
<span id="1749">1749</span>
<span id="1750">1750</span>
<span id="1751">1751</span>
<span id="1752">1752</span>
<span id="1753">1753</span>
<span id="1754">1754</span>
<span id="1755">1755</span>
<span id="1756">1756</span>
<span id="1757">1757</span>
<span id="1758">1758</span>
<span id="1759">1759</span>
<span id="1760">1760</span>
<span id="1761">1761</span>
<span id="1762">1762</span>
<span id="1763">1763</span>
<span id="1764">1764</span>
<span id="1765">1765</span>
<span id="1766">1766</span>
<span id="1767">1767</span>
<span id="1768">1768</span>
<span id="1769">1769</span>
<span id="1770">1770</span>
<span id="1771">1771</span>
<span id="1772">1772</span>
<span id="1773">1773</span>
<span id="1774">1774</span>
<span id="1775">1775</span>
<span id="1776">1776</span>
<span id="1777">1777</span>
<span id="1778">1778</span>
<span id="1779">1779</span>
<span id="1780">1780</span>
<span id="1781">1781</span>
<span id="1782">1782</span>
<span id="1783">1783</span>
<span id="1784">1784</span>
<span id="1785">1785</span>
<span id="1786">1786</span>
<span id="1787">1787</span>
<span id="1788">1788</span>
<span id="1789">1789</span>
<span id="1790">1790</span>
<span id="1791">1791</span>
<span id="1792">1792</span>
<span id="1793">1793</span>
<span id="1794">1794</span>
<span id="1795">1795</span>
<span id="1796">1796</span>
<span id="1797">1797</span>
<span id="1798">1798</span>
<span id="1799">1799</span>
<span id="1800">1800</span>
<span id="1801">1801</span>
<span id="1802">1802</span>
<span id="1803">1803</span>
<span id="1804">1804</span>
<span id="1805">1805</span>
<span id="1806">1806</span>
<span id="1807">1807</span>
<span id="1808">1808</span>
<span id="1809">1809</span>
<span id="1810">1810</span>
<span id="1811">1811</span>
<span id="1812">1812</span>
<span id="1813">1813</span>
<span id="1814">1814</span>
<span id="1815">1815</span>
<span id="1816">1816</span>
<span id="1817">1817</span>
<span id="1818">1818</span>
<span id="1819">1819</span>
<span id="1820">1820</span>
<span id="1821">1821</span>
<span id="1822">1822</span>
<span id="1823">1823</span>
<span id="1824">1824</span>
<span id="1825">1825</span>
<span id="1826">1826</span>
<span id="1827">1827</span>
<span id="1828">1828</span>
<span id="1829">1829</span>
<span id="1830">1830</span>
<span id="1831">1831</span>
<span id="1832">1832</span>
<span id="1833">1833</span>
<span id="1834">1834</span>
<span id="1835">1835</span>
<span id="1836">1836</span>
<span id="1837">1837</span>
<span id="1838">1838</span>
<span id="1839">1839</span>
<span id="1840">1840</span>
<span id="1841">1841</span>
<span id="1842">1842</span>
<span id="1843">1843</span>
<span id="1844">1844</span>
<span id="1845">1845</span>
<span id="1846">1846</span>
<span id="1847">1847</span>
<span id="1848">1848</span>
<span id="1849">1849</span>
<span id="1850">1850</span>
<span id="1851">1851</span>
<span id="1852">1852</span>
<span id="1853">1853</span>
<span id="1854">1854</span>
<span id="1855">1855</span>
<span id="1856">1856</span>
<span id="1857">1857</span>
<span id="1858">1858</span>
<span id="1859">1859</span>
<span id="1860">1860</span>
<span id="1861">1861</span>
<span id="1862">1862</span>
<span id="1863">1863</span>
<span id="1864">1864</span>
<span id="1865">1865</span>
<span id="1866">1866</span>
<span id="1867">1867</span>
<span id="1868">1868</span>
<span id="1869">1869</span>
<span id="1870">1870</span>
<span id="1871">1871</span>
<span id="1872">1872</span>
<span id="1873">1873</span>
<span id="1874">1874</span>
<span id="1875">1875</span>
<span id="1876">1876</span>
<span id="1877">1877</span>
<span id="1878">1878</span>
<span id="1879">1879</span>
<span id="1880">1880</span>
<span id="1881">1881</span>
<span id="1882">1882</span>
<span id="1883">1883</span>
<span id="1884">1884</span>
<span id="1885">1885</span>
<span id="1886">1886</span>
<span id="1887">1887</span>
<span id="1888">1888</span>
<span id="1889">1889</span>
<span id="1890">1890</span>
<span id="1891">1891</span>
<span id="1892">1892</span>
<span id="1893">1893</span>
<span id="1894">1894</span>
<span id="1895">1895</span>
<span id="1896">1896</span>
<span id="1897">1897</span>
<span id="1898">1898</span>
<span id="1899">1899</span>
<span id="1900">1900</span>
<span id="1901">1901</span>
<span id="1902">1902</span>
<span id="1903">1903</span>
<span id="1904">1904</span>
<span id="1905">1905</span>
<span id="1906">1906</span>
<span id="1907">1907</span>
<span id="1908">1908</span>
<span id="1909">1909</span>
<span id="1910">1910</span>
<span id="1911">1911</span>
<span id="1912">1912</span>
<span id="1913">1913</span>
<span id="1914">1914</span>
<span id="1915">1915</span>
<span id="1916">1916</span>
<span id="1917">1917</span>
<span id="1918">1918</span>
<span id="1919">1919</span>
<span id="1920">1920</span>
<span id="1921">1921</span>
<span id="1922">1922</span>
<span id="1923">1923</span>
<span id="1924">1924</span>
<span id="1925">1925</span>
<span id="1926">1926</span>
<span id="1927">1927</span>
<span id="1928">1928</span>
<span id="1929">1929</span>
<span id="1930">1930</span>
<span id="1931">1931</span>
<span id="1932">1932</span>
<span id="1933">1933</span>
<span id="1934">1934</span>
<span id="1935">1935</span>
<span id="1936">1936</span>
<span id="1937">1937</span>
<span id="1938">1938</span>
<span id="1939">1939</span>
<span id="1940">1940</span>
<span id="1941">1941</span>
<span id="1942">1942</span>
<span id="1943">1943</span>
<span id="1944">1944</span>
<span id="1945">1945</span>
<span id="1946">1946</span>
<span id="1947">1947</span>
<span id="1948">1948</span>
<span id="1949">1949</span>
<span id="1950">1950</span>
<span id="1951">1951</span>
<span id="1952">1952</span>
<span id="1953">1953</span>
<span id="1954">1954</span>
<span id="1955">1955</span>
<span id="1956">1956</span>
<span id="1957">1957</span>
<span id="1958">1958</span>
<span id="1959">1959</span>
<span id="1960">1960</span>
<span id="1961">1961</span>
<span id="1962">1962</span>
<span id="1963">1963</span>
<span id="1964">1964</span>
<span id="1965">1965</span>
<span id="1966">1966</span>
<span id="1967">1967</span>
<span id="1968">1968</span>
<span id="1969">1969</span>
<span id="1970">1970</span>
<span id="1971">1971</span>
<span id="1972">1972</span>
<span id="1973">1973</span>
<span id="1974">1974</span>
<span id="1975">1975</span>
<span id="1976">1976</span>
<span id="1977">1977</span>
<span id="1978">1978</span>
<span id="1979">1979</span>
<span id="1980">1980</span>
<span id="1981">1981</span>
<span id="1982">1982</span>
<span id="1983">1983</span>
<span id="1984">1984</span>
<span id="1985">1985</span>
<span id="1986">1986</span>
<span id="1987">1987</span>
<span id="1988">1988</span>
<span id="1989">1989</span>
<span id="1990">1990</span>
<span id="1991">1991</span>
<span id="1992">1992</span>
<span id="1993">1993</span>
<span id="1994">1994</span>
<span id="1995">1995</span>
<span id="1996">1996</span>
<span id="1997">1997</span>
<span id="1998">1998</span>
<span id="1999">1999</span>
<span id="2000">2000</span>
<span id="2001">2001</span>
<span id="2002">2002</span>
<span id="2003">2003</span>
<span id="2004">2004</span>
<span id="2005">2005</span>
<span id="2006">2006</span>
<span id="2007">2007</span>
<span id="2008">2008</span>
<span id="2009">2009</span>
<span id="2010">2010</span>
<span id="2011">2011</span>
<span id="2012">2012</span>
<span id="2013">2013</span>
<span id="2014">2014</span>
<span id="2015">2015</span>
<span id="2016">2016</span>
<span id="2017">2017</span>
<span id="2018">2018</span>
<span id="2019">2019</span>
<span id="2020">2020</span>
<span id="2021">2021</span>
<span id="2022">2022</span>
<span id="2023">2023</span>
<span id="2024">2024</span>
<span id="2025">2025</span>
<span id="2026">2026</span>
<span id="2027">2027</span>
<span id="2028">2028</span>
<span id="2029">2029</span>
<span id="2030">2030</span>
<span id="2031">2031</span>
<span id="2032">2032</span>
<span id="2033">2033</span>
<span id="2034">2034</span>
<span id="2035">2035</span>
<span id="2036">2036</span>
<span id="2037">2037</span>
<span id="2038">2038</span>
<span id="2039">2039</span>
<span id="2040">2040</span>
<span id="2041">2041</span>
<span id="2042">2042</span>
<span id="2043">2043</span>
<span id="2044">2044</span>
<span id="2045">2045</span>
<span id="2046">2046</span>
<span id="2047">2047</span>
<span id="2048">2048</span>
<span id="2049">2049</span>
<span id="2050">2050</span>
<span id="2051">2051</span>
<span id="2052">2052</span>
<span id="2053">2053</span>
<span id="2054">2054</span>
<span id="2055">2055</span>
<span id="2056">2056</span>
<span id="2057">2057</span>
<span id="2058">2058</span>
<span id="2059">2059</span>
<span id="2060">2060</span>
<span id="2061">2061</span>
<span id="2062">2062</span>
<span id="2063">2063</span>
<span id="2064">2064</span>
<span id="2065">2065</span>
<span id="2066">2066</span>
<span id="2067">2067</span>
<span id="2068">2068</span>
<span id="2069">2069</span>
<span id="2070">2070</span>
<span id="2071">2071</span>
<span id="2072">2072</span>
<span id="2073">2073</span>
<span id="2074">2074</span>
<span id="2075">2075</span>
<span id="2076">2076</span>
<span id="2077">2077</span>
<span id="2078">2078</span>
<span id="2079">2079</span>
<span id="2080">2080</span>
<span id="2081">2081</span>
<span id="2082">2082</span>
<span id="2083">2083</span>
<span id="2084">2084</span>
<span id="2085">2085</span>
<span id="2086">2086</span>
<span id="2087">2087</span>
<span id="2088">2088</span>
<span id="2089">2089</span>
<span id="2090">2090</span>
<span id="2091">2091</span>
<span id="2092">2092</span>
<span id="2093">2093</span>
<span id="2094">2094</span>
<span id="2095">2095</span>
<span id="2096">2096</span>
<span id="2097">2097</span>
<span id="2098">2098</span>
<span id="2099">2099</span>
<span id="2100">2100</span>
<span id="2101">2101</span>
<span id="2102">2102</span>
<span id="2103">2103</span>
<span id="2104">2104</span>
<span id="2105">2105</span>
<span id="2106">2106</span>
<span id="2107">2107</span>
<span id="2108">2108</span>
<span id="2109">2109</span>
<span id="2110">2110</span>
<span id="2111">2111</span>
<span id="2112">2112</span>
<span id="2113">2113</span>
<span id="2114">2114</span>
<span id="2115">2115</span>
<span id="2116">2116</span>
<span id="2117">2117</span>
<span id="2118">2118</span>
<span id="2119">2119</span>
<span id="2120">2120</span>
<span id="2121">2121</span>
<span id="2122">2122</span>
<span id="2123">2123</span>
<span id="2124">2124</span>
<span id="2125">2125</span>
<span id="2126">2126</span>
<span id="2127">2127</span>
<span id="2128">2128</span>
<span id="2129">2129</span>
<span id="2130">2130</span>
<span id="2131">2131</span>
<span id="2132">2132</span>
<span id="2133">2133</span>
<span id="2134">2134</span>
<span id="2135">2135</span>
<span id="2136">2136</span>
<span id="2137">2137</span>
<span id="2138">2138</span>
<span id="2139">2139</span>
<span id="2140">2140</span>
<span id="2141">2141</span>
<span id="2142">2142</span>
<span id="2143">2143</span>
<span id="2144">2144</span>
<span id="2145">2145</span>
<span id="2146">2146</span>
<span id="2147">2147</span>
<span id="2148">2148</span>
<span id="2149">2149</span>
<span id="2150">2150</span>
<span id="2151">2151</span>
<span id="2152">2152</span>
<span id="2153">2153</span>
<span id="2154">2154</span>
<span id="2155">2155</span>
<span id="2156">2156</span>
<span id="2157">2157</span>
<span id="2158">2158</span>
<span id="2159">2159</span>
<span id="2160">2160</span>
<span id="2161">2161</span>
<span id="2162">2162</span>
<span id="2163">2163</span>
<span id="2164">2164</span>
<span id="2165">2165</span>
<span id="2166">2166</span>
<span id="2167">2167</span>
<span id="2168">2168</span>
<span id="2169">2169</span>
<span id="2170">2170</span>
<span id="2171">2171</span>
<span id="2172">2172</span>
<span id="2173">2173</span>
<span id="2174">2174</span>
<span id="2175">2175</span>
<span id="2176">2176</span>
<span id="2177">2177</span>
<span id="2178">2178</span>
<span id="2179">2179</span>
<span id="2180">2180</span>
<span id="2181">2181</span>
<span id="2182">2182</span>
<span id="2183">2183</span>
<span id="2184">2184</span>
<span id="2185">2185</span>
<span id="2186">2186</span>
<span id="2187">2187</span>
<span id="2188">2188</span>
<span id="2189">2189</span>
<span id="2190">2190</span>
<span id="2191">2191</span>
<span id="2192">2192</span>
<span id="2193">2193</span>
<span id="2194">2194</span>
<span id="2195">2195</span>
<span id="2196">2196</span>
<span id="2197">2197</span>
<span id="2198">2198</span>
<span id="2199">2199</span>
<span id="2200">2200</span>
<span id="2201">2201</span>
<span id="2202">2202</span>
<span id="2203">2203</span>
<span id="2204">2204</span>
<span id="2205">2205</span>
<span id="2206">2206</span>
<span id="2207">2207</span>
<span id="2208">2208</span>
<span id="2209">2209</span>
<span id="2210">2210</span>
<span id="2211">2211</span>
<span id="2212">2212</span>
<span id="2213">2213</span>
<span id="2214">2214</span>
<span id="2215">2215</span>
<span id="2216">2216</span>
<span id="2217">2217</span>
<span id="2218">2218</span>
<span id="2219">2219</span>
<span id="2220">2220</span>
<span id="2221">2221</span>
<span id="2222">2222</span>
<span id="2223">2223</span>
<span id="2224">2224</span>
<span id="2225">2225</span>
<span id="2226">2226</span>
<span id="2227">2227</span>
<span id="2228">2228</span>
<span id="2229">2229</span>
<span id="2230">2230</span>
<span id="2231">2231</span>
<span id="2232">2232</span>
<span id="2233">2233</span>
<span id="2234">2234</span>
<span id="2235">2235</span>
<span id="2236">2236</span>
<span id="2237">2237</span>
<span id="2238">2238</span>
<span id="2239">2239</span>
<span id="2240">2240</span>
<span id="2241">2241</span>
<span id="2242">2242</span>
<span id="2243">2243</span>
<span id="2244">2244</span>
<span id="2245">2245</span>
<span id="2246">2246</span>
<span id="2247">2247</span>
<span id="2248">2248</span>
<span id="2249">2249</span>
<span id="2250">2250</span>
<span id="2251">2251</span>
<span id="2252">2252</span>
<span id="2253">2253</span>
<span id="2254">2254</span>
<span id="2255">2255</span>
<span id="2256">2256</span>
<span id="2257">2257</span>
<span id="2258">2258</span>
<span id="2259">2259</span>
<span id="2260">2260</span>
<span id="2261">2261</span>
<span id="2262">2262</span>
<span id="2263">2263</span>
<span id="2264">2264</span>
<span id="2265">2265</span>
<span id="2266">2266</span>
<span id="2267">2267</span>
<span id="2268">2268</span>
<span id="2269">2269</span>
<span id="2270">2270</span>
<span id="2271">2271</span>
<span id="2272">2272</span>
<span id="2273">2273</span>
<span id="2274">2274</span>
<span id="2275">2275</span>
<span id="2276">2276</span>
<span id="2277">2277</span>
<span id="2278">2278</span>
<span id="2279">2279</span>
<span id="2280">2280</span>
<span id="2281">2281</span>
<span id="2282">2282</span>
<span id="2283">2283</span>
<span id="2284">2284</span>
<span id="2285">2285</span>
<span id="2286">2286</span>
<span id="2287">2287</span>
<span id="2288">2288</span>
<span id="2289">2289</span>
<span id="2290">2290</span>
<span id="2291">2291</span>
<span id="2292">2292</span>
<span id="2293">2293</span>
<span id="2294">2294</span>
<span id="2295">2295</span>
<span id="2296">2296</span>
<span id="2297">2297</span>
<span id="2298">2298</span>
<span id="2299">2299</span>
<span id="2300">2300</span>
<span id="2301">2301</span>
<span id="2302">2302</span>
<span id="2303">2303</span>
<span id="2304">2304</span>
<span id="2305">2305</span>
<span id="2306">2306</span>
<span id="2307">2307</span>
<span id="2308">2308</span>
<span id="2309">2309</span>
<span id="2310">2310</span>
<span id="2311">2311</span>
<span id="2312">2312</span>
<span id="2313">2313</span>
<span id="2314">2314</span>
<span id="2315">2315</span>
<span id="2316">2316</span>
<span id="2317">2317</span>
<span id="2318">2318</span>
<span id="2319">2319</span>
<span id="2320">2320</span>
<span id="2321">2321</span>
<span id="2322">2322</span>
<span id="2323">2323</span>
<span id="2324">2324</span>
<span id="2325">2325</span>
<span id="2326">2326</span>
<span id="2327">2327</span>
<span id="2328">2328</span>
<span id="2329">2329</span>
<span id="2330">2330</span>
<span id="2331">2331</span>
<span id="2332">2332</span>
<span id="2333">2333</span>
<span id="2334">2334</span>
<span id="2335">2335</span>
<span id="2336">2336</span>
<span id="2337">2337</span>
<span id="2338">2338</span>
<span id="2339">2339</span>
<span id="2340">2340</span>
<span id="2341">2341</span>
<span id="2342">2342</span>
<span id="2343">2343</span>
<span id="2344">2344</span>
<span id="2345">2345</span>
<span id="2346">2346</span>
<span id="2347">2347</span>
<span id="2348">2348</span>
<span id="2349">2349</span>
<span id="2350">2350</span>
<span id="2351">2351</span>
<span id="2352">2352</span>
<span id="2353">2353</span>
<span id="2354">2354</span>
<span id="2355">2355</span>
<span id="2356">2356</span>
<span id="2357">2357</span>
<span id="2358">2358</span>
<span id="2359">2359</span>
<span id="2360">2360</span>
<span id="2361">2361</span>
<span id="2362">2362</span>
<span id="2363">2363</span>
<span id="2364">2364</span>
<span id="2365">2365</span>
<span id="2366">2366</span>
<span id="2367">2367</span>
<span id="2368">2368</span>
<span id="2369">2369</span>
<span id="2370">2370</span>
<span id="2371">2371</span>
<span id="2372">2372</span>
<span id="2373">2373</span>
<span id="2374">2374</span>
<span id="2375">2375</span>
<span id="2376">2376</span>
<span id="2377">2377</span>
<span id="2378">2378</span>
<span id="2379">2379</span>
<span id="2380">2380</span>
<span id="2381">2381</span>
<span id="2382">2382</span>
<span id="2383">2383</span>
<span id="2384">2384</span>
<span id="2385">2385</span>
<span id="2386">2386</span>
<span id="2387">2387</span>
<span id="2388">2388</span>
<span id="2389">2389</span>
<span id="2390">2390</span>
<span id="2391">2391</span>
<span id="2392">2392</span>
<span id="2393">2393</span>
<span id="2394">2394</span>
<span id="2395">2395</span>
<span id="2396">2396</span>
<span id="2397">2397</span>
<span id="2398">2398</span>
<span id="2399">2399</span>
<span id="2400">2400</span>
<span id="2401">2401</span>
<span id="2402">2402</span>
<span id="2403">2403</span>
<span id="2404">2404</span>
<span id="2405">2405</span>
<span id="2406">2406</span>
<span id="2407">2407</span>
<span id="2408">2408</span>
<span id="2409">2409</span>
<span id="2410">2410</span>
<span id="2411">2411</span>
<span id="2412">2412</span>
<span id="2413">2413</span>
<span id="2414">2414</span>
<span id="2415">2415</span>
<span id="2416">2416</span>
<span id="2417">2417</span>
<span id="2418">2418</span>
<span id="2419">2419</span>
<span id="2420">2420</span>
<span id="2421">2421</span>
<span id="2422">2422</span>
<span id="2423">2423</span>
<span id="2424">2424</span>
<span id="2425">2425</span>
<span id="2426">2426</span>
<span id="2427">2427</span>
<span id="2428">2428</span>
<span id="2429">2429</span>
<span id="2430">2430</span>
<span id="2431">2431</span>
<span id="2432">2432</span>
<span id="2433">2433</span>
<span id="2434">2434</span>
<span id="2435">2435</span>
<span id="2436">2436</span>
<span id="2437">2437</span>
<span id="2438">2438</span>
<span id="2439">2439</span>
<span id="2440">2440</span>
<span id="2441">2441</span>
<span id="2442">2442</span>
<span id="2443">2443</span>
<span id="2444">2444</span>
<span id="2445">2445</span>
<span id="2446">2446</span>
<span id="2447">2447</span>
<span id="2448">2448</span>
<span id="2449">2449</span>
<span id="2450">2450</span>
<span id="2451">2451</span>
<span id="2452">2452</span>
<span id="2453">2453</span>
<span id="2454">2454</span>
<span id="2455">2455</span>
<span id="2456">2456</span>
<span id="2457">2457</span>
<span id="2458">2458</span>
<span id="2459">2459</span>
<span id="2460">2460</span>
<span id="2461">2461</span>
<span id="2462">2462</span>
<span id="2463">2463</span>
<span id="2464">2464</span>
<span id="2465">2465</span>
<span id="2466">2466</span>
<span id="2467">2467</span>
<span id="2468">2468</span>
<span id="2469">2469</span>
<span id="2470">2470</span>
<span id="2471">2471</span>
<span id="2472">2472</span>
<span id="2473">2473</span>
<span id="2474">2474</span>
<span id="2475">2475</span>
<span id="2476">2476</span>
<span id="2477">2477</span>
<span id="2478">2478</span>
<span id="2479">2479</span>
<span id="2480">2480</span>
<span id="2481">2481</span>
<span id="2482">2482</span>
<span id="2483">2483</span>
<span id="2484">2484</span>
<span id="2485">2485</span>
<span id="2486">2486</span>
<span id="2487">2487</span>
<span id="2488">2488</span>
<span id="2489">2489</span>
<span id="2490">2490</span>
<span id="2491">2491</span>
<span id="2492">2492</span>
<span id="2493">2493</span>
<span id="2494">2494</span>
<span id="2495">2495</span>
<span id="2496">2496</span>
<span id="2497">2497</span>
<span id="2498">2498</span>
<span id="2499">2499</span>
<span id="2500">2500</span>
<span id="2501">2501</span>
<span id="2502">2502</span>
<span id="2503">2503</span>
<span id="2504">2504</span>
<span id="2505">2505</span>
<span id="2506">2506</span>
<span id="2507">2507</span>
<span id="2508">2508</span>
<span id="2509">2509</span>
<span id="2510">2510</span>
<span id="2511">2511</span>
<span id="2512">2512</span>
<span id="2513">2513</span>
<span id="2514">2514</span>
<span id="2515">2515</span>
<span id="2516">2516</span>
<span id="2517">2517</span>
<span id="2518">2518</span>
<span id="2519">2519</span>
<span id="2520">2520</span>
<span id="2521">2521</span>
<span id="2522">2522</span>
<span id="2523">2523</span>
<span id="2524">2524</span>
<span id="2525">2525</span>
<span id="2526">2526</span>
<span id="2527">2527</span>
<span id="2528">2528</span>
<span id="2529">2529</span>
<span id="2530">2530</span>
<span id="2531">2531</span>
<span id="2532">2532</span>
<span id="2533">2533</span>
<span id="2534">2534</span>
<span id="2535">2535</span>
<span id="2536">2536</span>
<span id="2537">2537</span>
<span id="2538">2538</span>
<span id="2539">2539</span>
<span id="2540">2540</span>
<span id="2541">2541</span>
<span id="2542">2542</span>
<span id="2543">2543</span>
<span id="2544">2544</span>
<span id="2545">2545</span>
<span id="2546">2546</span>
<span id="2547">2547</span>
<span id="2548">2548</span>
<span id="2549">2549</span>
<span id="2550">2550</span>
<span id="2551">2551</span>
<span id="2552">2552</span>
<span id="2553">2553</span>
<span id="2554">2554</span>
<span id="2555">2555</span>
<span id="2556">2556</span>
<span id="2557">2557</span>
<span id="2558">2558</span>
<span id="2559">2559</span>
<span id="2560">2560</span>
<span id="2561">2561</span>
<span id="2562">2562</span>
<span id="2563">2563</span>
<span id="2564">2564</span>
<span id="2565">2565</span>
<span id="2566">2566</span>
<span id="2567">2567</span>
<span id="2568">2568</span>
<span id="2569">2569</span>
<span id="2570">2570</span>
<span id="2571">2571</span>
<span id="2572">2572</span>
<span id="2573">2573</span>
<span id="2574">2574</span>
<span id="2575">2575</span>
<span id="2576">2576</span>
<span id="2577">2577</span>
<span id="2578">2578</span>
<span id="2579">2579</span>
<span id="2580">2580</span>
<span id="2581">2581</span>
<span id="2582">2582</span>
<span id="2583">2583</span>
<span id="2584">2584</span>
<span id="2585">2585</span>
<span id="2586">2586</span>
<span id="2587">2587</span>
<span id="2588">2588</span>
<span id="2589">2589</span>
<span id="2590">2590</span>
<span id="2591">2591</span>
<span id="2592">2592</span>
<span id="2593">2593</span>
<span id="2594">2594</span>
<span id="2595">2595</span>
<span id="2596">2596</span>
<span id="2597">2597</span>
<span id="2598">2598</span>
<span id="2599">2599</span>
<span id="2600">2600</span>
<span id="2601">2601</span>
<span id="2602">2602</span>
<span id="2603">2603</span>
<span id="2604">2604</span>
<span id="2605">2605</span>
<span id="2606">2606</span>
<span id="2607">2607</span>
<span id="2608">2608</span>
<span id="2609">2609</span>
<span id="2610">2610</span>
<span id="2611">2611</span>
<span id="2612">2612</span>
<span id="2613">2613</span>
<span id="2614">2614</span>
<span id="2615">2615</span>
<span id="2616">2616</span>
<span id="2617">2617</span>
<span id="2618">2618</span>
<span id="2619">2619</span>
<span id="2620">2620</span>
<span id="2621">2621</span>
<span id="2622">2622</span>
<span id="2623">2623</span>
<span id="2624">2624</span>
<span id="2625">2625</span>
<span id="2626">2626</span>
<span id="2627">2627</span>
<span id="2628">2628</span>
<span id="2629">2629</span>
<span id="2630">2630</span>
<span id="2631">2631</span>
<span id="2632">2632</span>
<span id="2633">2633</span>
<span id="2634">2634</span>
<span id="2635">2635</span>
<span id="2636">2636</span>
<span id="2637">2637</span>
<span id="2638">2638</span>
<span id="2639">2639</span>
<span id="2640">2640</span>
<span id="2641">2641</span>
<span id="2642">2642</span>
<span id="2643">2643</span>
<span id="2644">2644</span>
<span id="2645">2645</span>
<span id="2646">2646</span>
<span id="2647">2647</span>
<span id="2648">2648</span>
<span id="2649">2649</span>
<span id="2650">2650</span>
<span id="2651">2651</span>
<span id="2652">2652</span>
<span id="2653">2653</span>
<span id="2654">2654</span>
<span id="2655">2655</span>
<span id="2656">2656</span>
<span id="2657">2657</span>
<span id="2658">2658</span>
<span id="2659">2659</span>
<span id="2660">2660</span>
<span id="2661">2661</span>
<span id="2662">2662</span>
<span id="2663">2663</span>
<span id="2664">2664</span>
<span id="2665">2665</span>
<span id="2666">2666</span>
<span id="2667">2667</span>
<span id="2668">2668</span>
<span id="2669">2669</span>
<span id="2670">2670</span>
<span id="2671">2671</span>
<span id="2672">2672</span>
<span id="2673">2673</span>
<span id="2674">2674</span>
<span id="2675">2675</span>
<span id="2676">2676</span>
<span id="2677">2677</span>
<span id="2678">2678</span>
<span id="2679">2679</span>
<span id="2680">2680</span>
<span id="2681">2681</span>
<span id="2682">2682</span>
<span id="2683">2683</span>
<span id="2684">2684</span>
<span id="2685">2685</span>
<span id="2686">2686</span>
<span id="2687">2687</span>
<span id="2688">2688</span>
<span id="2689">2689</span>
<span id="2690">2690</span>
<span id="2691">2691</span>
<span id="2692">2692</span>
<span id="2693">2693</span>
<span id="2694">2694</span>
<span id="2695">2695</span>
<span id="2696">2696</span>
<span id="2697">2697</span>
<span id="2698">2698</span>
<span id="2699">2699</span>
<span id="2700">2700</span>
<span id="2701">2701</span>
<span id="2702">2702</span>
<span id="2703">2703</span>
<span id="2704">2704</span>
<span id="2705">2705</span>
<span id="2706">2706</span>
<span id="2707">2707</span>
<span id="2708">2708</span>
<span id="2709">2709</span>
<span id="2710">2710</span>
<span id="2711">2711</span>
<span id="2712">2712</span>
<span id="2713">2713</span>
<span id="2714">2714</span>
<span id="2715">2715</span>
<span id="2716">2716</span>
<span id="2717">2717</span>
<span id="2718">2718</span>
<span id="2719">2719</span>
<span id="2720">2720</span>
<span id="2721">2721</span>
<span id="2722">2722</span>
<span id="2723">2723</span>
<span id="2724">2724</span>
<span id="2725">2725</span>
<span id="2726">2726</span>
<span id="2727">2727</span>
<span id="2728">2728</span>
<span id="2729">2729</span>
<span id="2730">2730</span>
<span id="2731">2731</span>
<span id="2732">2732</span>
<span id="2733">2733</span>
<span id="2734">2734</span>
<span id="2735">2735</span>
<span id="2736">2736</span>
<span id="2737">2737</span>
<span id="2738">2738</span>
<span id="2739">2739</span>
<span id="2740">2740</span>
<span id="2741">2741</span>
<span id="2742">2742</span>
<span id="2743">2743</span>
<span id="2744">2744</span>
<span id="2745">2745</span>
<span id="2746">2746</span>
<span id="2747">2747</span>
<span id="2748">2748</span>
<span id="2749">2749</span>
<span id="2750">2750</span>
<span id="2751">2751</span>
<span id="2752">2752</span>
<span id="2753">2753</span>
<span id="2754">2754</span>
<span id="2755">2755</span>
<span id="2756">2756</span>
<span id="2757">2757</span>
<span id="2758">2758</span>
<span id="2759">2759</span>
<span id="2760">2760</span>
<span id="2761">2761</span>
<span id="2762">2762</span>
<span id="2763">2763</span>
<span id="2764">2764</span>
<span id="2765">2765</span>
<span id="2766">2766</span>
<span id="2767">2767</span>
<span id="2768">2768</span>
<span id="2769">2769</span>
<span id="2770">2770</span>
<span id="2771">2771</span>
<span id="2772">2772</span>
<span id="2773">2773</span>
<span id="2774">2774</span>
<span id="2775">2775</span>
<span id="2776">2776</span>
<span id="2777">2777</span>
<span id="2778">2778</span>
<span id="2779">2779</span>
<span id="2780">2780</span>
<span id="2781">2781</span>
<span id="2782">2782</span>
<span id="2783">2783</span>
<span id="2784">2784</span>
<span id="2785">2785</span>
<span id="2786">2786</span>
<span id="2787">2787</span>
<span id="2788">2788</span>
<span id="2789">2789</span>
<span id="2790">2790</span>
<span id="2791">2791</span>
<span id="2792">2792</span>
<span id="2793">2793</span>
<span id="2794">2794</span>
<span id="2795">2795</span>
<span id="2796">2796</span>
<span id="2797">2797</span>
<span id="2798">2798</span>
<span id="2799">2799</span>
<span id="2800">2800</span>
<span id="2801">2801</span>
<span id="2802">2802</span>
<span id="2803">2803</span>
<span id="2804">2804</span>
<span id="2805">2805</span>
<span id="2806">2806</span>
<span id="2807">2807</span>
<span id="2808">2808</span>
<span id="2809">2809</span>
<span id="2810">2810</span>
<span id="2811">2811</span>
<span id="2812">2812</span>
<span id="2813">2813</span>
<span id="2814">2814</span>
<span id="2815">2815</span>
<span id="2816">2816</span>
<span id="2817">2817</span>
<span id="2818">2818</span>
<span id="2819">2819</span>
<span id="2820">2820</span>
<span id="2821">2821</span>
<span id="2822">2822</span>
<span id="2823">2823</span>
<span id="2824">2824</span>
<span id="2825">2825</span>
<span id="2826">2826</span>
<span id="2827">2827</span>
<span id="2828">2828</span>
<span id="2829">2829</span>
<span id="2830">2830</span>
<span id="2831">2831</span>
<span id="2832">2832</span>
<span id="2833">2833</span>
<span id="2834">2834</span>
<span id="2835">2835</span>
<span id="2836">2836</span>
<span id="2837">2837</span>
<span id="2838">2838</span>
<span id="2839">2839</span>
<span id="2840">2840</span>
<span id="2841">2841</span>
<span id="2842">2842</span>
<span id="2843">2843</span>
<span id="2844">2844</span>
<span id="2845">2845</span>
<span id="2846">2846</span>
<span id="2847">2847</span>
<span id="2848">2848</span>
<span id="2849">2849</span>
<span id="2850">2850</span>
<span id="2851">2851</span>
<span id="2852">2852</span>
<span id="2853">2853</span>
<span id="2854">2854</span>
<span id="2855">2855</span>
<span id="2856">2856</span>
<span id="2857">2857</span>
<span id="2858">2858</span>
<span id="2859">2859</span>
<span id="2860">2860</span>
<span id="2861">2861</span>
<span id="2862">2862</span>
<span id="2863">2863</span>
<span id="2864">2864</span>
<span id="2865">2865</span>
<span id="2866">2866</span>
<span id="2867">2867</span>
<span id="2868">2868</span>
<span id="2869">2869</span>
<span id="2870">2870</span>
<span id="2871">2871</span>
<span id="2872">2872</span>
<span id="2873">2873</span>
<span id="2874">2874</span>
<span id="2875">2875</span>
<span id="2876">2876</span>
<span id="2877">2877</span>
<span id="2878">2878</span>
<span id="2879">2879</span>
<span id="2880">2880</span>
<span id="2881">2881</span>
<span id="2882">2882</span>
<span id="2883">2883</span>
<span id="2884">2884</span>
<span id="2885">2885</span>
<span id="2886">2886</span>
<span id="2887">2887</span>
<span id="2888">2888</span>
<span id="2889">2889</span>
<span id="2890">2890</span>
<span id="2891">2891</span>
<span id="2892">2892</span>
<span id="2893">2893</span>
<span id="2894">2894</span>
<span id="2895">2895</span>
<span id="2896">2896</span>
<span id="2897">2897</span>
<span id="2898">2898</span>
<span id="2899">2899</span>
<span id="2900">2900</span>
<span id="2901">2901</span>
<span id="2902">2902</span>
<span id="2903">2903</span>
<span id="2904">2904</span>
<span id="2905">2905</span>
<span id="2906">2906</span>
<span id="2907">2907</span>
<span id="2908">2908</span>
<span id="2909">2909</span>
<span id="2910">2910</span>
<span id="2911">2911</span>
<span id="2912">2912</span>
<span id="2913">2913</span>
<span id="2914">2914</span>
<span id="2915">2915</span>
<span id="2916">2916</span>
<span id="2917">2917</span>
<span id="2918">2918</span>
<span id="2919">2919</span>
<span id="2920">2920</span>
<span id="2921">2921</span>
<span id="2922">2922</span>
<span id="2923">2923</span>
<span id="2924">2924</span>
<span id="2925">2925</span>
<span id="2926">2926</span>
<span id="2927">2927</span>
<span id="2928">2928</span>
<span id="2929">2929</span>
<span id="2930">2930</span>
<span id="2931">2931</span>
<span id="2932">2932</span>
<span id="2933">2933</span>
<span id="2934">2934</span>
<span id="2935">2935</span>
<span id="2936">2936</span>
<span id="2937">2937</span>
<span id="2938">2938</span>
<span id="2939">2939</span>
<span id="2940">2940</span>
<span id="2941">2941</span>
<span id="2942">2942</span>
<span id="2943">2943</span>
<span id="2944">2944</span>
<span id="2945">2945</span>
<span id="2946">2946</span>
<span id="2947">2947</span>
<span id="2948">2948</span>
<span id="2949">2949</span>
<span id="2950">2950</span>
<span id="2951">2951</span>
<span id="2952">2952</span>
<span id="2953">2953</span>
<span id="2954">2954</span>
<span id="2955">2955</span>
<span id="2956">2956</span>
<span id="2957">2957</span>
<span id="2958">2958</span>
<span id="2959">2959</span>
<span id="2960">2960</span>
<span id="2961">2961</span>
<span id="2962">2962</span>
<span id="2963">2963</span>
<span id="2964">2964</span>
<span id="2965">2965</span>
<span id="2966">2966</span>
<span id="2967">2967</span>
<span id="2968">2968</span>
<span id="2969">2969</span>
<span id="2970">2970</span>
<span id="2971">2971</span>
<span id="2972">2972</span>
<span id="2973">2973</span>
<span id="2974">2974</span>
<span id="2975">2975</span>
<span id="2976">2976</span>
<span id="2977">2977</span>
<span id="2978">2978</span>
<span id="2979">2979</span>
<span id="2980">2980</span>
<span id="2981">2981</span>
<span id="2982">2982</span>
<span id="2983">2983</span>
<span id="2984">2984</span>
<span id="2985">2985</span>
<span id="2986">2986</span>
<span id="2987">2987</span>
<span id="2988">2988</span>
<span id="2989">2989</span>
<span id="2990">2990</span>
<span id="2991">2991</span>
<span id="2992">2992</span>
<span id="2993">2993</span>
<span id="2994">2994</span>
<span id="2995">2995</span>
<span id="2996">2996</span>
<span id="2997">2997</span>
<span id="2998">2998</span>
<span id="2999">2999</span>
<span id="3000">3000</span>
<span id="3001">3001</span>
<span id="3002">3002</span>
<span id="3003">3003</span>
<span id="3004">3004</span>
<span id="3005">3005</span>
<span id="3006">3006</span>
<span id="3007">3007</span>
<span id="3008">3008</span>
<span id="3009">3009</span>
<span id="3010">3010</span>
<span id="3011">3011</span>
<span id="3012">3012</span>
<span id="3013">3013</span>
<span id="3014">3014</span>
<span id="3015">3015</span>
<span id="3016">3016</span>
<span id="3017">3017</span>
<span id="3018">3018</span>
<span id="3019">3019</span>
<span id="3020">3020</span>
<span id="3021">3021</span>
<span id="3022">3022</span>
<span id="3023">3023</span>
<span id="3024">3024</span>
<span id="3025">3025</span>
<span id="3026">3026</span>
<span id="3027">3027</span>
<span id="3028">3028</span>
<span id="3029">3029</span>
<span id="3030">3030</span>
<span id="3031">3031</span>
<span id="3032">3032</span>
<span id="3033">3033</span>
<span id="3034">3034</span>
<span id="3035">3035</span>
<span id="3036">3036</span>
<span id="3037">3037</span>
<span id="3038">3038</span>
<span id="3039">3039</span>
<span id="3040">3040</span>
<span id="3041">3041</span>
<span id="3042">3042</span>
<span id="3043">3043</span>
<span id="3044">3044</span>
<span id="3045">3045</span>
<span id="3046">3046</span>
<span id="3047">3047</span>
<span id="3048">3048</span>
<span id="3049">3049</span>
<span id="3050">3050</span>
<span id="3051">3051</span>
<span id="3052">3052</span>
<span id="3053">3053</span>
<span id="3054">3054</span>
<span id="3055">3055</span>
<span id="3056">3056</span>
<span id="3057">3057</span>
<span id="3058">3058</span>
<span id="3059">3059</span>
<span id="3060">3060</span>
<span id="3061">3061</span>
<span id="3062">3062</span>
<span id="3063">3063</span>
<span id="3064">3064</span>
<span id="3065">3065</span>
<span id="3066">3066</span>
<span id="3067">3067</span>
<span id="3068">3068</span>
<span id="3069">3069</span>
<span id="3070">3070</span>
<span id="3071">3071</span>
<span id="3072">3072</span>
<span id="3073">3073</span>
<span id="3074">3074</span>
<span id="3075">3075</span>
<span id="3076">3076</span>
<span id="3077">3077</span>
<span id="3078">3078</span>
<span id="3079">3079</span>
<span id="3080">3080</span>
<span id="3081">3081</span>
<span id="3082">3082</span>
<span id="3083">3083</span>
<span id="3084">3084</span>
<span id="3085">3085</span>
<span id="3086">3086</span>
<span id="3087">3087</span>
<span id="3088">3088</span>
<span id="3089">3089</span>
<span id="3090">3090</span>
<span id="3091">3091</span>
<span id="3092">3092</span>
<span id="3093">3093</span>
<span id="3094">3094</span>
<span id="3095">3095</span>
<span id="3096">3096</span>
<span id="3097">3097</span>
<span id="3098">3098</span>
<span id="3099">3099</span>
<span id="3100">3100</span>
<span id="3101">3101</span>
<span id="3102">3102</span>
<span id="3103">3103</span>
<span id="3104">3104</span>
<span id="3105">3105</span>
<span id="3106">3106</span>
<span id="3107">3107</span>
<span id="3108">3108</span>
<span id="3109">3109</span>
<span id="3110">3110</span>
<span id="3111">3111</span>
<span id="3112">3112</span>
<span id="3113">3113</span>
<span id="3114">3114</span>
<span id="3115">3115</span>
<span id="3116">3116</span>
<span id="3117">3117</span>
<span id="3118">3118</span>
<span id="3119">3119</span>
<span id="3120">3120</span>
<span id="3121">3121</span>
<span id="3122">3122</span>
<span id="3123">3123</span>
<span id="3124">3124</span>
<span id="3125">3125</span>
<span id="3126">3126</span>
<span id="3127">3127</span>
<span id="3128">3128</span>
<span id="3129">3129</span>
<span id="3130">3130</span>
<span id="3131">3131</span>
<span id="3132">3132</span>
<span id="3133">3133</span>
<span id="3134">3134</span>
<span id="3135">3135</span>
<span id="3136">3136</span>
<span id="3137">3137</span>
<span id="3138">3138</span>
<span id="3139">3139</span>
<span id="3140">3140</span>
<span id="3141">3141</span>
<span id="3142">3142</span>
<span id="3143">3143</span>
<span id="3144">3144</span>
<span id="3145">3145</span>
<span id="3146">3146</span>
<span id="3147">3147</span>
<span id="3148">3148</span>
<span id="3149">3149</span>
<span id="3150">3150</span>
<span id="3151">3151</span>
<span id="3152">3152</span>
<span id="3153">3153</span>
<span id="3154">3154</span>
<span id="3155">3155</span>
<span id="3156">3156</span>
<span id="3157">3157</span>
<span id="3158">3158</span>
<span id="3159">3159</span>
<span id="3160">3160</span>
<span id="3161">3161</span>
<span id="3162">3162</span>
<span id="3163">3163</span>
<span id="3164">3164</span>
<span id="3165">3165</span>
<span id="3166">3166</span>
<span id="3167">3167</span>
<span id="3168">3168</span>
<span id="3169">3169</span>
<span id="3170">3170</span>
<span id="3171">3171</span>
<span id="3172">3172</span>
<span id="3173">3173</span>
<span id="3174">3174</span>
<span id="3175">3175</span>
<span id="3176">3176</span>
<span id="3177">3177</span>
<span id="3178">3178</span>
<span id="3179">3179</span>
<span id="3180">3180</span>
<span id="3181">3181</span>
<span id="3182">3182</span>
<span id="3183">3183</span>
<span id="3184">3184</span>
<span id="3185">3185</span>
<span id="3186">3186</span>
<span id="3187">3187</span>
<span id="3188">3188</span>
<span id="3189">3189</span>
<span id="3190">3190</span>
<span id="3191">3191</span>
<span id="3192">3192</span>
<span id="3193">3193</span>
<span id="3194">3194</span>
<span id="3195">3195</span>
<span id="3196">3196</span>
<span id="3197">3197</span>
<span id="3198">3198</span>
<span id="3199">3199</span>
<span id="3200">3200</span>
<span id="3201">3201</span>
<span id="3202">3202</span>
<span id="3203">3203</span>
<span id="3204">3204</span>
<span id="3205">3205</span>
<span id="3206">3206</span>
<span id="3207">3207</span>
<span id="3208">3208</span>
<span id="3209">3209</span>
<span id="3210">3210</span>
<span id="3211">3211</span>
<span id="3212">3212</span>
<span id="3213">3213</span>
<span id="3214">3214</span>
<span id="3215">3215</span>
<span id="3216">3216</span>
<span id="3217">3217</span>
<span id="3218">3218</span>
<span id="3219">3219</span>
<span id="3220">3220</span>
<span id="3221">3221</span>
<span id="3222">3222</span>
<span id="3223">3223</span>
<span id="3224">3224</span>
<span id="3225">3225</span>
<span id="3226">3226</span>
<span id="3227">3227</span>
<span id="3228">3228</span>
<span id="3229">3229</span>
<span id="3230">3230</span>
<span id="3231">3231</span>
<span id="3232">3232</span>
<span id="3233">3233</span>
<span id="3234">3234</span>
<span id="3235">3235</span>
<span id="3236">3236</span>
<span id="3237">3237</span>
<span id="3238">3238</span>
<span id="3239">3239</span>
<span id="3240">3240</span>
<span id="3241">3241</span>
<span id="3242">3242</span>
<span id="3243">3243</span>
<span id="3244">3244</span>
<span id="3245">3245</span>
<span id="3246">3246</span>
<span id="3247">3247</span>
<span id="3248">3248</span>
<span id="3249">3249</span>
<span id="3250">3250</span>
<span id="3251">3251</span>
<span id="3252">3252</span>
<span id="3253">3253</span>
<span id="3254">3254</span>
<span id="3255">3255</span>
<span id="3256">3256</span>
<span id="3257">3257</span>
<span id="3258">3258</span>
<span id="3259">3259</span>
<span id="3260">3260</span>
<span id="3261">3261</span>
<span id="3262">3262</span>
<span id="3263">3263</span>
<span id="3264">3264</span>
<span id="3265">3265</span>
<span id="3266">3266</span>
<span id="3267">3267</span>
<span id="3268">3268</span>
<span id="3269">3269</span>
<span id="3270">3270</span>
<span id="3271">3271</span>
<span id="3272">3272</span>
<span id="3273">3273</span>
<span id="3274">3274</span>
<span id="3275">3275</span>
<span id="3276">3276</span>
<span id="3277">3277</span>
<span id="3278">3278</span>
<span id="3279">3279</span>
<span id="3280">3280</span>
<span id="3281">3281</span>
<span id="3282">3282</span>
<span id="3283">3283</span>
<span id="3284">3284</span>
<span id="3285">3285</span>
<span id="3286">3286</span>
<span id="3287">3287</span>
<span id="3288">3288</span>
<span id="3289">3289</span>
<span id="3290">3290</span>
<span id="3291">3291</span>
<span id="3292">3292</span>
<span id="3293">3293</span>
<span id="3294">3294</span>
<span id="3295">3295</span>
<span id="3296">3296</span>
<span id="3297">3297</span>
<span id="3298">3298</span>
<span id="3299">3299</span>
<span id="3300">3300</span>
<span id="3301">3301</span>
<span id="3302">3302</span>
<span id="3303">3303</span>
<span id="3304">3304</span>
<span id="3305">3305</span>
<span id="3306">3306</span>
<span id="3307">3307</span>
<span id="3308">3308</span>
<span id="3309">3309</span>
<span id="3310">3310</span>
<span id="3311">3311</span>
<span id="3312">3312</span>
<span id="3313">3313</span>
<span id="3314">3314</span>
<span id="3315">3315</span>
<span id="3316">3316</span>
<span id="3317">3317</span>
<span id="3318">3318</span>
<span id="3319">3319</span>
<span id="3320">3320</span>
<span id="3321">3321</span>
<span id="3322">3322</span>
<span id="3323">3323</span>
<span id="3324">3324</span>
<span id="3325">3325</span>
<span id="3326">3326</span>
<span id="3327">3327</span>
<span id="3328">3328</span>
<span id="3329">3329</span>
<span id="3330">3330</span>
<span id="3331">3331</span>
<span id="3332">3332</span>
<span id="3333">3333</span>
<span id="3334">3334</span>
<span id="3335">3335</span>
<span id="3336">3336</span>
<span id="3337">3337</span>
<span id="3338">3338</span>
<span id="3339">3339</span>
<span id="3340">3340</span>
<span id="3341">3341</span>
<span id="3342">3342</span>
<span id="3343">3343</span>
<span id="3344">3344</span>
<span id="3345">3345</span>
<span id="3346">3346</span>
<span id="3347">3347</span>
<span id="3348">3348</span>
<span id="3349">3349</span>
<span id="3350">3350</span>
<span id="3351">3351</span>
<span id="3352">3352</span>
<span id="3353">3353</span>
<span id="3354">3354</span>
<span id="3355">3355</span>
<span id="3356">3356</span>
<span id="3357">3357</span>
<span id="3358">3358</span>
<span id="3359">3359</span>
<span id="3360">3360</span>
<span id="3361">3361</span>
<span id="3362">3362</span>
<span id="3363">3363</span>
<span id="3364">3364</span>
<span id="3365">3365</span>
<span id="3366">3366</span>
<span id="3367">3367</span>
<span id="3368">3368</span>
<span id="3369">3369</span>
<span id="3370">3370</span>
<span id="3371">3371</span>
<span id="3372">3372</span>
<span id="3373">3373</span>
<span id="3374">3374</span>
<span id="3375">3375</span>
<span id="3376">3376</span>
<span id="3377">3377</span>
<span id="3378">3378</span>
<span id="3379">3379</span>
<span id="3380">3380</span>
<span id="3381">3381</span>
<span id="3382">3382</span>
<span id="3383">3383</span>
<span id="3384">3384</span>
<span id="3385">3385</span>
<span id="3386">3386</span>
<span id="3387">3387</span>
<span id="3388">3388</span>
<span id="3389">3389</span>
<span id="3390">3390</span>
<span id="3391">3391</span>
<span id="3392">3392</span>
<span id="3393">3393</span>
<span id="3394">3394</span>
<span id="3395">3395</span>
<span id="3396">3396</span>
<span id="3397">3397</span>
<span id="3398">3398</span>
<span id="3399">3399</span>
<span id="3400">3400</span>
<span id="3401">3401</span>
<span id="3402">3402</span>
<span id="3403">3403</span>
<span id="3404">3404</span>
<span id="3405">3405</span>
<span id="3406">3406</span>
<span id="3407">3407</span>
<span id="3408">3408</span>
<span id="3409">3409</span>
<span id="3410">3410</span>
<span id="3411">3411</span>
<span id="3412">3412</span>
<span id="3413">3413</span>
<span id="3414">3414</span>
<span id="3415">3415</span>
<span id="3416">3416</span>
<span id="3417">3417</span>
<span id="3418">3418</span>
<span id="3419">3419</span>
<span id="3420">3420</span>
<span id="3421">3421</span>
<span id="3422">3422</span>
<span id="3423">3423</span>
<span id="3424">3424</span>
<span id="3425">3425</span>
<span id="3426">3426</span>
<span id="3427">3427</span>
<span id="3428">3428</span>
<span id="3429">3429</span>
<span id="3430">3430</span>
<span id="3431">3431</span>
<span id="3432">3432</span>
<span id="3433">3433</span>
<span id="3434">3434</span>
<span id="3435">3435</span>
<span id="3436">3436</span>
<span id="3437">3437</span>
<span id="3438">3438</span>
<span id="3439">3439</span>
<span id="3440">3440</span>
<span id="3441">3441</span>
<span id="3442">3442</span>
<span id="3443">3443</span>
<span id="3444">3444</span>
<span id="3445">3445</span>
<span id="3446">3446</span>
<span id="3447">3447</span>
<span id="3448">3448</span>
<span id="3449">3449</span>
<span id="3450">3450</span>
<span id="3451">3451</span>
<span id="3452">3452</span>
<span id="3453">3453</span>
<span id="3454">3454</span>
<span id="3455">3455</span>
<span id="3456">3456</span>
<span id="3457">3457</span>
<span id="3458">3458</span>
<span id="3459">3459</span>
<span id="3460">3460</span>
<span id="3461">3461</span>
<span id="3462">3462</span>
<span id="3463">3463</span>
<span id="3464">3464</span>
<span id="3465">3465</span>
<span id="3466">3466</span>
<span id="3467">3467</span>
<span id="3468">3468</span>
<span id="3469">3469</span>
<span id="3470">3470</span>
<span id="3471">3471</span>
<span id="3472">3472</span>
<span id="3473">3473</span>
<span id="3474">3474</span>
<span id="3475">3475</span>
<span id="3476">3476</span>
<span id="3477">3477</span>
<span id="3478">3478</span>
<span id="3479">3479</span>
<span id="3480">3480</span>
<span id="3481">3481</span>
<span id="3482">3482</span>
<span id="3483">3483</span>
<span id="3484">3484</span>
<span id="3485">3485</span>
<span id="3486">3486</span>
<span id="3487">3487</span>
<span id="3488">3488</span>
<span id="3489">3489</span>
<span id="3490">3490</span>
<span id="3491">3491</span>
<span id="3492">3492</span>
<span id="3493">3493</span>
<span id="3494">3494</span>
<span id="3495">3495</span>
<span id="3496">3496</span>
<span id="3497">3497</span>
<span id="3498">3498</span>
<span id="3499">3499</span>
<span id="3500">3500</span>
<span id="3501">3501</span>
<span id="3502">3502</span>
<span id="3503">3503</span>
<span id="3504">3504</span>
<span id="3505">3505</span>
<span id="3506">3506</span>
<span id="3507">3507</span>
<span id="3508">3508</span>
<span id="3509">3509</span>
<span id="3510">3510</span>
<span id="3511">3511</span>
<span id="3512">3512</span>
<span id="3513">3513</span>
<span id="3514">3514</span>
<span id="3515">3515</span>
<span id="3516">3516</span>
<span id="3517">3517</span>
<span id="3518">3518</span>
<span id="3519">3519</span>
<span id="3520">3520</span>
<span id="3521">3521</span>
<span id="3522">3522</span>
<span id="3523">3523</span>
<span id="3524">3524</span>
<span id="3525">3525</span>
<span id="3526">3526</span>
<span id="3527">3527</span>
<span id="3528">3528</span>
<span id="3529">3529</span>
<span id="3530">3530</span>
<span id="3531">3531</span>
<span id="3532">3532</span>
<span id="3533">3533</span>
<span id="3534">3534</span>
<span id="3535">3535</span>
<span id="3536">3536</span>
<span id="3537">3537</span>
<span id="3538">3538</span>
<span id="3539">3539</span>
<span id="3540">3540</span>
<span id="3541">3541</span>
<span id="3542">3542</span>
<span id="3543">3543</span>
<span id="3544">3544</span>
<span id="3545">3545</span>
<span id="3546">3546</span>
<span id="3547">3547</span>
<span id="3548">3548</span>
<span id="3549">3549</span>
<span id="3550">3550</span>
<span id="3551">3551</span>
<span id="3552">3552</span>
<span id="3553">3553</span>
<span id="3554">3554</span>
<span id="3555">3555</span>
<span id="3556">3556</span>
<span id="3557">3557</span>
<span id="3558">3558</span>
<span id="3559">3559</span>
<span id="3560">3560</span>
<span id="3561">3561</span>
<span id="3562">3562</span>
<span id="3563">3563</span>
<span id="3564">3564</span>
<span id="3565">3565</span>
<span id="3566">3566</span>
<span id="3567">3567</span>
<span id="3568">3568</span>
<span id="3569">3569</span>
<span id="3570">3570</span>
<span id="3571">3571</span>
<span id="3572">3572</span>
<span id="3573">3573</span>
<span id="3574">3574</span>
<span id="3575">3575</span>
<span id="3576">3576</span>
<span id="3577">3577</span>
<span id="3578">3578</span>
<span id="3579">3579</span>
<span id="3580">3580</span>
<span id="3581">3581</span>
<span id="3582">3582</span>
<span id="3583">3583</span>
<span id="3584">3584</span>
<span id="3585">3585</span>
<span id="3586">3586</span>
<span id="3587">3587</span>
<span id="3588">3588</span>
<span id="3589">3589</span>
<span id="3590">3590</span>
<span id="3591">3591</span>
<span id="3592">3592</span>
<span id="3593">3593</span>
<span id="3594">3594</span>
<span id="3595">3595</span>
<span id="3596">3596</span>
<span id="3597">3597</span>
<span id="3598">3598</span>
<span id="3599">3599</span>
<span id="3600">3600</span>
<span id="3601">3601</span>
<span id="3602">3602</span>
<span id="3603">3603</span>
<span id="3604">3604</span>
<span id="3605">3605</span>
<span id="3606">3606</span>
<span id="3607">3607</span>
<span id="3608">3608</span>
<span id="3609">3609</span>
<span id="3610">3610</span>
<span id="3611">3611</span>
<span id="3612">3612</span>
<span id="3613">3613</span>
<span id="3614">3614</span>
<span id="3615">3615</span>
<span id="3616">3616</span>
<span id="3617">3617</span>
<span id="3618">3618</span>
<span id="3619">3619</span>
<span id="3620">3620</span>
<span id="3621">3621</span>
<span id="3622">3622</span>
<span id="3623">3623</span>
<span id="3624">3624</span>
<span id="3625">3625</span>
<span id="3626">3626</span>
<span id="3627">3627</span>
<span id="3628">3628</span>
<span id="3629">3629</span>
<span id="3630">3630</span>
<span id="3631">3631</span>
<span id="3632">3632</span>
<span id="3633">3633</span>
<span id="3634">3634</span>
<span id="3635">3635</span>
<span id="3636">3636</span>
<span id="3637">3637</span>
<span id="3638">3638</span>
<span id="3639">3639</span>
<span id="3640">3640</span>
<span id="3641">3641</span>
<span id="3642">3642</span>
<span id="3643">3643</span>
<span id="3644">3644</span>
<span id="3645">3645</span>
<span id="3646">3646</span>
<span id="3647">3647</span>
<span id="3648">3648</span>
<span id="3649">3649</span>
<span id="3650">3650</span>
<span id="3651">3651</span>
<span id="3652">3652</span>
<span id="3653">3653</span>
<span id="3654">3654</span>
<span id="3655">3655</span>
<span id="3656">3656</span>
<span id="3657">3657</span>
<span id="3658">3658</span>
<span id="3659">3659</span>
<span id="3660">3660</span>
<span id="3661">3661</span>
<span id="3662">3662</span>
<span id="3663">3663</span>
<span id="3664">3664</span>
<span id="3665">3665</span>
<span id="3666">3666</span>
<span id="3667">3667</span>
<span id="3668">3668</span>
<span id="3669">3669</span>
<span id="3670">3670</span>
<span id="3671">3671</span>
<span id="3672">3672</span>
<span id="3673">3673</span>
<span id="3674">3674</span>
<span id="3675">3675</span>
<span id="3676">3676</span>
<span id="3677">3677</span>
<span id="3678">3678</span>
<span id="3679">3679</span>
<span id="3680">3680</span>
<span id="3681">3681</span>
<span id="3682">3682</span>
<span id="3683">3683</span>
<span id="3684">3684</span>
<span id="3685">3685</span>
<span id="3686">3686</span>
<span id="3687">3687</span>
<span id="3688">3688</span>
<span id="3689">3689</span>
<span id="3690">3690</span>
<span id="3691">3691</span>
<span id="3692">3692</span>
<span id="3693">3693</span>
<span id="3694">3694</span>
<span id="3695">3695</span>
<span id="3696">3696</span>
<span id="3697">3697</span>
<span id="3698">3698</span>
<span id="3699">3699</span>
<span id="3700">3700</span>
<span id="3701">3701</span>
<span id="3702">3702</span>
<span id="3703">3703</span>
<span id="3704">3704</span>
<span id="3705">3705</span>
<span id="3706">3706</span>
<span id="3707">3707</span>
<span id="3708">3708</span>
<span id="3709">3709</span>
<span id="3710">3710</span>
<span id="3711">3711</span>
<span id="3712">3712</span>
<span id="3713">3713</span>
<span id="3714">3714</span>
<span id="3715">3715</span>
<span id="3716">3716</span>
<span id="3717">3717</span>
<span id="3718">3718</span>
<span id="3719">3719</span>
<span id="3720">3720</span>
<span id="3721">3721</span>
<span id="3722">3722</span>
<span id="3723">3723</span>
<span id="3724">3724</span>
<span id="3725">3725</span>
<span id="3726">3726</span>
<span id="3727">3727</span>
<span id="3728">3728</span>
<span id="3729">3729</span>
<span id="3730">3730</span>
<span id="3731">3731</span>
<span id="3732">3732</span>
<span id="3733">3733</span>
<span id="3734">3734</span>
<span id="3735">3735</span>
<span id="3736">3736</span>
<span id="3737">3737</span>
<span id="3738">3738</span>
<span id="3739">3739</span>
<span id="3740">3740</span>
<span id="3741">3741</span>
<span id="3742">3742</span>
<span id="3743">3743</span>
<span id="3744">3744</span>
<span id="3745">3745</span>
<span id="3746">3746</span>
<span id="3747">3747</span>
<span id="3748">3748</span>
<span id="3749">3749</span>
<span id="3750">3750</span>
<span id="3751">3751</span>
<span id="3752">3752</span>
<span id="3753">3753</span>
<span id="3754">3754</span>
<span id="3755">3755</span>
<span id="3756">3756</span>
<span id="3757">3757</span>
<span id="3758">3758</span>
<span id="3759">3759</span>
<span id="3760">3760</span>
<span id="3761">3761</span>
<span id="3762">3762</span>
<span id="3763">3763</span>
<span id="3764">3764</span>
<span id="3765">3765</span>
<span id="3766">3766</span>
<span id="3767">3767</span>
<span id="3768">3768</span>
<span id="3769">3769</span>
<span id="3770">3770</span>
<span id="3771">3771</span>
<span id="3772">3772</span>
<span id="3773">3773</span>
<span id="3774">3774</span>
<span id="3775">3775</span>
<span id="3776">3776</span>
<span id="3777">3777</span>
<span id="3778">3778</span>
<span id="3779">3779</span>
<span id="3780">3780</span>
<span id="3781">3781</span>
<span id="3782">3782</span>
<span id="3783">3783</span>
<span id="3784">3784</span>
<span id="3785">3785</span>
<span id="3786">3786</span>
<span id="3787">3787</span>
<span id="3788">3788</span>
<span id="3789">3789</span>
<span id="3790">3790</span>
<span id="3791">3791</span>
<span id="3792">3792</span>
<span id="3793">3793</span>
<span id="3794">3794</span>
<span id="3795">3795</span>
<span id="3796">3796</span>
<span id="3797">3797</span>
<span id="3798">3798</span>
<span id="3799">3799</span>
<span id="3800">3800</span>
<span id="3801">3801</span>
<span id="3802">3802</span>
<span id="3803">3803</span>
<span id="3804">3804</span>
<span id="3805">3805</span>
<span id="3806">3806</span>
<span id="3807">3807</span>
<span id="3808">3808</span>
<span id="3809">3809</span>
<span id="3810">3810</span>
<span id="3811">3811</span>
<span id="3812">3812</span>
<span id="3813">3813</span>
<span id="3814">3814</span>
<span id="3815">3815</span>
<span id="3816">3816</span>
<span id="3817">3817</span>
<span id="3818">3818</span>
<span id="3819">3819</span>
<span id="3820">3820</span>
<span id="3821">3821</span>
<span id="3822">3822</span>
<span id="3823">3823</span>
<span id="3824">3824</span>
<span id="3825">3825</span>
<span id="3826">3826</span>
<span id="3827">3827</span>
<span id="3828">3828</span>
<span id="3829">3829</span>
<span id="3830">3830</span>
<span id="3831">3831</span>
<span id="3832">3832</span>
<span id="3833">3833</span>
<span id="3834">3834</span>
<span id="3835">3835</span>
<span id="3836">3836</span>
<span id="3837">3837</span>
<span id="3838">3838</span>
<span id="3839">3839</span>
<span id="3840">3840</span>
<span id="3841">3841</span>
<span id="3842">3842</span>
<span id="3843">3843</span>
<span id="3844">3844</span>
<span id="3845">3845</span>
<span id="3846">3846</span>
<span id="3847">3847</span>
<span id="3848">3848</span>
<span id="3849">3849</span>
<span id="3850">3850</span>
<span id="3851">3851</span>
<span id="3852">3852</span>
<span id="3853">3853</span>
<span id="3854">3854</span>
<span id="3855">3855</span>
<span id="3856">3856</span>
<span id="3857">3857</span>
<span id="3858">3858</span>
<span id="3859">3859</span>
<span id="3860">3860</span>
<span id="3861">3861</span>
<span id="3862">3862</span>
<span id="3863">3863</span>
<span id="3864">3864</span>
<span id="3865">3865</span>
<span id="3866">3866</span>
<span id="3867">3867</span>
<span id="3868">3868</span>
<span id="3869">3869</span>
<span id="3870">3870</span>
<span id="3871">3871</span>
<span id="3872">3872</span>
<span id="3873">3873</span>
<span id="3874">3874</span>
<span id="3875">3875</span>
<span id="3876">3876</span>
<span id="3877">3877</span>
<span id="3878">3878</span>
<span id="3879">3879</span>
<span id="3880">3880</span>
<span id="3881">3881</span>
<span id="3882">3882</span>
<span id="3883">3883</span>
<span id="3884">3884</span>
<span id="3885">3885</span>
<span id="3886">3886</span>
<span id="3887">3887</span>
<span id="3888">3888</span>
<span id="3889">3889</span>
<span id="3890">3890</span>
<span id="3891">3891</span>
<span id="3892">3892</span>
<span id="3893">3893</span>
<span id="3894">3894</span>
<span id="3895">3895</span>
<span id="3896">3896</span>
<span id="3897">3897</span>
<span id="3898">3898</span>
<span id="3899">3899</span>
<span id="3900">3900</span>
<span id="3901">3901</span>
<span id="3902">3902</span>
<span id="3903">3903</span>
<span id="3904">3904</span>
<span id="3905">3905</span>
<span id="3906">3906</span>
<span id="3907">3907</span>
<span id="3908">3908</span>
<span id="3909">3909</span>
<span id="3910">3910</span>
<span id="3911">3911</span>
<span id="3912">3912</span>
<span id="3913">3913</span>
<span id="3914">3914</span>
<span id="3915">3915</span>
<span id="3916">3916</span>
<span id="3917">3917</span>
<span id="3918">3918</span>
<span id="3919">3919</span>
<span id="3920">3920</span>
<span id="3921">3921</span>
<span id="3922">3922</span>
<span id="3923">3923</span>
<span id="3924">3924</span>
<span id="3925">3925</span>
<span id="3926">3926</span>
<span id="3927">3927</span>
<span id="3928">3928</span>
<span id="3929">3929</span>
<span id="3930">3930</span>
<span id="3931">3931</span>
<span id="3932">3932</span>
<span id="3933">3933</span>
<span id="3934">3934</span>
<span id="3935">3935</span>
<span id="3936">3936</span>
<span id="3937">3937</span>
<span id="3938">3938</span>
<span id="3939">3939</span>
<span id="3940">3940</span>
<span id="3941">3941</span>
<span id="3942">3942</span>
<span id="3943">3943</span>
<span id="3944">3944</span>
<span id="3945">3945</span>
<span id="3946">3946</span>
<span id="3947">3947</span>
<span id="3948">3948</span>
<span id="3949">3949</span>
<span id="3950">3950</span>
<span id="3951">3951</span>
<span id="3952">3952</span>
<span id="3953">3953</span>
<span id="3954">3954</span>
<span id="3955">3955</span>
<span id="3956">3956</span>
<span id="3957">3957</span>
<span id="3958">3958</span>
<span id="3959">3959</span>
<span id="3960">3960</span>
<span id="3961">3961</span>
<span id="3962">3962</span>
<span id="3963">3963</span>
<span id="3964">3964</span>
<span id="3965">3965</span>
<span id="3966">3966</span>
<span id="3967">3967</span>
<span id="3968">3968</span>
<span id="3969">3969</span>
<span id="3970">3970</span>
<span id="3971">3971</span>
<span id="3972">3972</span>
<span id="3973">3973</span>
<span id="3974">3974</span>
<span id="3975">3975</span>
<span id="3976">3976</span>
<span id="3977">3977</span>
<span id="3978">3978</span>
<span id="3979">3979</span>
<span id="3980">3980</span>
<span id="3981">3981</span>
<span id="3982">3982</span>
<span id="3983">3983</span>
<span id="3984">3984</span>
<span id="3985">3985</span>
<span id="3986">3986</span>
<span id="3987">3987</span>
<span id="3988">3988</span>
<span id="3989">3989</span>
<span id="3990">3990</span>
<span id="3991">3991</span>
<span id="3992">3992</span>
<span id="3993">3993</span>
<span id="3994">3994</span>
<span id="3995">3995</span>
<span id="3996">3996</span>
<span id="3997">3997</span>
<span id="3998">3998</span>
<span id="3999">3999</span>
<span id="4000">4000</span>
<span id="4001">4001</span>
<span id="4002">4002</span>
<span id="4003">4003</span>
<span id="4004">4004</span>
<span id="4005">4005</span>
<span id="4006">4006</span>
<span id="4007">4007</span>
<span id="4008">4008</span>
<span id="4009">4009</span>
<span id="4010">4010</span>
<span id="4011">4011</span>
<span id="4012">4012</span>
<span id="4013">4013</span>
<span id="4014">4014</span>
<span id="4015">4015</span>
<span id="4016">4016</span>
<span id="4017">4017</span>
<span id="4018">4018</span>
<span id="4019">4019</span>
<span id="4020">4020</span>
<span id="4021">4021</span>
<span id="4022">4022</span>
<span id="4023">4023</span>
<span id="4024">4024</span>
<span id="4025">4025</span>
<span id="4026">4026</span>
<span id="4027">4027</span>
<span id="4028">4028</span>
<span id="4029">4029</span>
<span id="4030">4030</span>
<span id="4031">4031</span>
<span id="4032">4032</span>
<span id="4033">4033</span>
<span id="4034">4034</span>
<span id="4035">4035</span>
<span id="4036">4036</span>
<span id="4037">4037</span>
<span id="4038">4038</span>
<span id="4039">4039</span>
<span id="4040">4040</span>
<span id="4041">4041</span>
<span id="4042">4042</span>
<span id="4043">4043</span>
<span id="4044">4044</span>
<span id="4045">4045</span>
<span id="4046">4046</span>
<span id="4047">4047</span>
<span id="4048">4048</span>
<span id="4049">4049</span>
<span id="4050">4050</span>
<span id="4051">4051</span>
<span id="4052">4052</span>
<span id="4053">4053</span>
<span id="4054">4054</span>
<span id="4055">4055</span>
<span id="4056">4056</span>
<span id="4057">4057</span>
<span id="4058">4058</span>
<span id="4059">4059</span>
<span id="4060">4060</span>
<span id="4061">4061</span>
<span id="4062">4062</span>
<span id="4063">4063</span>
<span id="4064">4064</span>
<span id="4065">4065</span>
<span id="4066">4066</span>
<span id="4067">4067</span>
<span id="4068">4068</span>
<span id="4069">4069</span>
<span id="4070">4070</span>
<span id="4071">4071</span>
<span id="4072">4072</span>
<span id="4073">4073</span>
<span id="4074">4074</span>
<span id="4075">4075</span>
<span id="4076">4076</span>
<span id="4077">4077</span>
<span id="4078">4078</span>
<span id="4079">4079</span>
<span id="4080">4080</span>
<span id="4081">4081</span>
<span id="4082">4082</span>
<span id="4083">4083</span>
<span id="4084">4084</span>
<span id="4085">4085</span>
<span id="4086">4086</span>
<span id="4087">4087</span>
<span id="4088">4088</span>
<span id="4089">4089</span>
<span id="4090">4090</span>
<span id="4091">4091</span>
<span id="4092">4092</span>
<span id="4093">4093</span>
<span id="4094">4094</span>
<span id="4095">4095</span>
<span id="4096">4096</span>
<span id="4097">4097</span>
<span id="4098">4098</span>
<span id="4099">4099</span>
<span id="4100">4100</span>
<span id="4101">4101</span>
<span id="4102">4102</span>
<span id="4103">4103</span>
<span id="4104">4104</span>
<span id="4105">4105</span>
<span id="4106">4106</span>
<span id="4107">4107</span>
<span id="4108">4108</span>
<span id="4109">4109</span>
<span id="4110">4110</span>
<span id="4111">4111</span>
<span id="4112">4112</span>
<span id="4113">4113</span>
<span id="4114">4114</span>
<span id="4115">4115</span>
<span id="4116">4116</span>
<span id="4117">4117</span>
<span id="4118">4118</span>
<span id="4119">4119</span>
<span id="4120">4120</span>
<span id="4121">4121</span>
<span id="4122">4122</span>
<span id="4123">4123</span>
<span id="4124">4124</span>
<span id="4125">4125</span>
<span id="4126">4126</span>
<span id="4127">4127</span>
<span id="4128">4128</span>
<span id="4129">4129</span>
<span id="4130">4130</span>
<span id="4131">4131</span>
<span id="4132">4132</span>
<span id="4133">4133</span>
<span id="4134">4134</span>
<span id="4135">4135</span>
<span id="4136">4136</span>
<span id="4137">4137</span>
<span id="4138">4138</span>
<span id="4139">4139</span>
<span id="4140">4140</span>
<span id="4141">4141</span>
<span id="4142">4142</span>
<span id="4143">4143</span>
<span id="4144">4144</span>
<span id="4145">4145</span>
<span id="4146">4146</span>
<span id="4147">4147</span>
<span id="4148">4148</span>
<span id="4149">4149</span>
<span id="4150">4150</span>
<span id="4151">4151</span>
<span id="4152">4152</span>
<span id="4153">4153</span>
<span id="4154">4154</span>
<span id="4155">4155</span>
<span id="4156">4156</span>
<span id="4157">4157</span>
<span id="4158">4158</span>
<span id="4159">4159</span>
<span id="4160">4160</span>
<span id="4161">4161</span>
<span id="4162">4162</span>
<span id="4163">4163</span>
<span id="4164">4164</span>
<span id="4165">4165</span>
<span id="4166">4166</span>
<span id="4167">4167</span>
<span id="4168">4168</span>
<span id="4169">4169</span>
<span id="4170">4170</span>
<span id="4171">4171</span>
<span id="4172">4172</span>
<span id="4173">4173</span>
<span id="4174">4174</span>
<span id="4175">4175</span>
<span id="4176">4176</span>
<span id="4177">4177</span>
<span id="4178">4178</span>
<span id="4179">4179</span>
<span id="4180">4180</span>
<span id="4181">4181</span>
<span id="4182">4182</span>
<span id="4183">4183</span>
<span id="4184">4184</span>
<span id="4185">4185</span>
<span id="4186">4186</span>
<span id="4187">4187</span>
<span id="4188">4188</span>
<span id="4189">4189</span>
<span id="4190">4190</span>
<span id="4191">4191</span>
<span id="4192">4192</span>
<span id="4193">4193</span>
<span id="4194">4194</span>
<span id="4195">4195</span>
<span id="4196">4196</span>
<span id="4197">4197</span>
<span id="4198">4198</span>
<span id="4199">4199</span>
<span id="4200">4200</span>
<span id="4201">4201</span>
<span id="4202">4202</span>
<span id="4203">4203</span>
<span id="4204">4204</span>
<span id="4205">4205</span>
<span id="4206">4206</span>
<span id="4207">4207</span>
<span id="4208">4208</span>
<span id="4209">4209</span>
</pre><pre class="rust">
<span class="comment">// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">BatchExecuteStatementInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// The list of PartiQL statements representing the batch to run.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">statements</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::BatchStatementRequest</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">BatchExecuteStatementInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;BatchExecuteStatementInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;statements&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">statements</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of a &lt;code&gt;BatchGetItem&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">BatchGetItemInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;A map of one or more table names and, for each table, a map that describes one or more items to retrieve from that table. Each table name can be used only once per &lt;code&gt;BatchGetItem&lt;/code&gt; request.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Each element in the map of items to retrieve consists of the following:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ConsistentRead&lt;/code&gt; - If &lt;code&gt;true&lt;/code&gt;, a strongly consistent read is used; if</span>
    <span class="doccomment">/// &lt;code&gt;false&lt;/code&gt; (the default), an eventually consistent read is used.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ExpressionAttributeNames&lt;/code&gt; - One or more substitution tokens for attribute names in the &lt;code&gt;ProjectionExpression&lt;/code&gt; parameter. The following are some use cases for using &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To access an attribute whose name conflicts with a DynamoDB reserved word.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To create a placeholder for repeating occurrences of an attribute name in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To prevent special characters in an attribute name from being misinterpreted in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Use the &lt;b&gt;#&lt;/b&gt; character in an expression to dereference an attribute name. For example, consider the following attribute name:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Percentile&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The name of this attribute conflicts with a reserved word, so it cannot be used directly in an expression. (For the complete list of reserved words, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html&quot;&gt;Reserved Words&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;). To work around this, you could specify the following for &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;{&quot;#P&quot;:&quot;Percentile&quot;}&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You could then use this substitution in an expression, as in this example:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;#P = :val&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Tokens that begin with the &lt;b&gt;:&lt;/b&gt; character are &lt;i&gt;expression attribute values&lt;/i&gt;, which are placeholders for the actual value at runtime.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information about expression attribute names, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html&quot;&gt;Accessing Item Attributes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB</span>
    <span class="doccomment">/// Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Keys&lt;/code&gt; - An array of primary key attribute values that define specific items in the</span>
    <span class="doccomment">/// table. For each primary key, you must provide &lt;i&gt;all&lt;/i&gt; of the key attributes. For</span>
    <span class="doccomment">/// example, with a simple primary key, you only need to provide the partition key value. For a</span>
    <span class="doccomment">/// composite key, you must provide &lt;i&gt;both&lt;/i&gt; the partition key value and the sort key value.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ProjectionExpression&lt;/code&gt; - A string that identifies one or more</span>
    <span class="doccomment">/// attributes to retrieve from the table. These attributes can include scalars,</span>
    <span class="doccomment">/// sets, or elements of a JSON document. The attributes in the expression must be</span>
    <span class="doccomment">/// separated by commas.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If no attribute names are specified, then all attributes are returned. If any</span>
    <span class="doccomment">/// of the requested attributes are not found, they do not appear in the</span>
    <span class="doccomment">/// result.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html&quot;&gt;Accessing Item Attributes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;AttributesToGet&lt;/code&gt; - This is a legacy parameter.  Use &lt;code&gt;ProjectionExpression&lt;/code&gt; instead.  For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html&quot;&gt;AttributesToGet&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">request_items</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::KeysAndAttributes</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines the level of detail about provisioned throughput consumption that is returned in the response:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;INDEXES&lt;/code&gt; - The response includes the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation, together with &lt;code&gt;ConsumedCapacity&lt;/code&gt; for each table and secondary index that was accessed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Note that some operations, such as &lt;code&gt;GetItem&lt;/code&gt; and &lt;code&gt;BatchGetItem&lt;/code&gt;, do not access any indexes at all.  In these cases, specifying &lt;code&gt;INDEXES&lt;/code&gt; will only return &lt;code&gt;ConsumedCapacity&lt;/code&gt; information for table(s).&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;TOTAL&lt;/code&gt; - The response includes only the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt; - No &lt;code&gt;ConsumedCapacity&lt;/code&gt; details are included in the response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_consumed_capacity</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnConsumedCapacity</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">BatchGetItemInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;BatchGetItemInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;request_items&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">request_items</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;return_consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of a &lt;code&gt;BatchWriteItem&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">BatchWriteItemInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;A map of one or more table names and, for each table, a list of operations to be performed</span>
    <span class="doccomment">/// (&lt;code&gt;DeleteRequest&lt;/code&gt; or &lt;code&gt;PutRequest&lt;/code&gt;). Each element in the map consists of the</span>
    <span class="doccomment">/// following:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;DeleteRequest&lt;/code&gt; - Perform a &lt;code&gt;DeleteItem&lt;/code&gt; operation on the specified item. The</span>
    <span class="doccomment">/// item to be deleted is identified by a &lt;code&gt;Key&lt;/code&gt; subelement:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Key&lt;/code&gt; - A map of primary key attribute values that uniquely identify the item.</span>
    <span class="doccomment">/// Each entry in this map consists of an attribute name and an attribute value. For each</span>
    <span class="doccomment">/// primary key, you must provide &lt;i&gt;all&lt;/i&gt; of the key attributes. For example, with a</span>
    <span class="doccomment">/// simple primary key, you only need to provide a value for the partition key. For a</span>
    <span class="doccomment">/// composite primary key, you must provide values for &lt;i&gt;both&lt;/i&gt; the partition key and the sort key.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;PutRequest&lt;/code&gt; - Perform a &lt;code&gt;PutItem&lt;/code&gt; operation on the specified item. The item to</span>
    <span class="doccomment">/// be put is identified by an &lt;code&gt;Item&lt;/code&gt; subelement:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Item&lt;/code&gt; - A map of attributes and their values. Each entry in</span>
    <span class="doccomment">/// this map consists of an attribute name and an attribute value. Attribute</span>
    <span class="doccomment">/// values must not be null; string and binary type attributes must have</span>
    <span class="doccomment">/// lengths greater than zero; and set type attributes must not be empty.</span>
    <span class="doccomment">/// Requests that contain empty values are rejected with a</span>
    <span class="doccomment">/// &lt;code&gt;ValidationException&lt;/code&gt; exception.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you specify any attributes that are part of an index key, then the data types for those attributes must match those of the schema in the table&#39;s attribute definition.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">request_items</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::WriteRequest</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines the level of detail about provisioned throughput consumption that is returned in the response:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;INDEXES&lt;/code&gt; - The response includes the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation, together with &lt;code&gt;ConsumedCapacity&lt;/code&gt; for each table and secondary index that was accessed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Note that some operations, such as &lt;code&gt;GetItem&lt;/code&gt; and &lt;code&gt;BatchGetItem&lt;/code&gt;, do not access any indexes at all.  In these cases, specifying &lt;code&gt;INDEXES&lt;/code&gt; will only return &lt;code&gt;ConsumedCapacity&lt;/code&gt; information for table(s).&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;TOTAL&lt;/code&gt; - The response includes only the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt; - No &lt;code&gt;ConsumedCapacity&lt;/code&gt; details are included in the response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_consumed_capacity</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnConsumedCapacity</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines whether item collection metrics are returned.  If set to &lt;code&gt;SIZE&lt;/code&gt;, the response includes statistics about item collections, if any, that were modified during</span>
    <span class="doccomment">/// the operation are returned in the response. If set to &lt;code&gt;NONE&lt;/code&gt; (the default), no statistics are returned.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_item_collection_metrics</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnItemCollectionMetrics</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">BatchWriteItemInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;BatchWriteItemInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;request_items&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">request_items</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;return_consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;return_item_collection_metrics&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_item_collection_metrics</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">CreateBackupInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Specified name for the backup.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">backup_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">CreateBackupInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;CreateBackupInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;backup_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">backup_name</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">CreateGlobalTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The global table name.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The Regions where the global table needs to be created.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">replication_group</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::Replica</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">CreateGlobalTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;CreateGlobalTableInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;global_table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;replication_group&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">replication_group</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of a &lt;code&gt;CreateTable&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">CreateTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;An array of attributes that describe the key schema for the table and indexes.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">attribute_definitions</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::AttributeDefinition</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The name of the table to create.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Specifies the attributes that make up the primary key for a table or an index. The attributes</span>
    <span class="doccomment">/// in &lt;code&gt;KeySchema&lt;/code&gt; must also be defined in the &lt;code&gt;AttributeDefinitions&lt;/code&gt; array. For more</span>
    <span class="doccomment">/// information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html&quot;&gt;Data Model&lt;/a&gt; in the</span>
    <span class="doccomment">/// &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Each &lt;code&gt;KeySchemaElement&lt;/code&gt; in the array is composed of:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;AttributeName&lt;/code&gt; - The name of this key attribute.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;KeyType&lt;/code&gt; - The role that the key attribute will assume:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;HASH&lt;/code&gt; - partition key&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;RANGE&lt;/code&gt; - sort key&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The partition key of an item is also known as its &lt;i&gt;hash</span>
    <span class="doccomment">/// attribute&lt;/i&gt;. The term &quot;hash attribute&quot; derives from the DynamoDB usage of</span>
    <span class="doccomment">/// an internal hash function to evenly distribute data items across partitions, based</span>
    <span class="doccomment">/// on their partition key values.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The sort key of an item is also known as its &lt;i&gt;range attribute&lt;/i&gt;.</span>
    <span class="doccomment">/// The term &quot;range attribute&quot; derives from the way DynamoDB stores items with the same</span>
    <span class="doccomment">/// partition key physically close together, in sorted order by the sort key value.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For a simple primary key (partition key), you must provide</span>
    <span class="doccomment">/// exactly one element with a &lt;code&gt;KeyType&lt;/code&gt; of &lt;code&gt;HASH&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For a composite primary key (partition key and sort key), you must provide exactly two</span>
    <span class="doccomment">/// elements, in this order: The first element must have a &lt;code&gt;KeyType&lt;/code&gt; of &lt;code&gt;HASH&lt;/code&gt;,</span>
    <span class="doccomment">/// and the second element must have a &lt;code&gt;KeyType&lt;/code&gt; of &lt;code&gt;RANGE&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#WorkingWithTables.primary.key&quot;&gt;Working with Tables&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">key_schema</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::KeySchemaElement</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;One or more local secondary indexes (the maximum is 5) to be created on the table. Each index is scoped to a given partition key value. There is a 10 GB size limit per partition key value; otherwise, the size of a local secondary index is unconstrained.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Each local secondary index in the array includes the following:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;IndexName&lt;/code&gt; - The name of the local secondary index. Must be unique only for this table.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;KeySchema&lt;/code&gt; - Specifies the key schema for the local secondary index. The key schema must begin with</span>
    <span class="doccomment">/// the same partition key as the table.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Projection&lt;/code&gt; - Specifies</span>
    <span class="doccomment">/// attributes that are copied (projected) from the table into the index. These are in</span>
    <span class="doccomment">/// addition to the primary key attributes and index key</span>
    <span class="doccomment">/// attributes, which are automatically projected. Each</span>
    <span class="doccomment">/// attribute specification is composed of:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ProjectionType&lt;/code&gt; - One</span>
    <span class="doccomment">/// of the following:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;KEYS_ONLY&lt;/code&gt; - Only the index and primary keys are projected into the</span>
    <span class="doccomment">/// index.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;INCLUDE&lt;/code&gt; - Only the specified table attributes are</span>
    <span class="doccomment">/// projected into the index. The list of projected attributes is in</span>
    <span class="doccomment">/// &lt;code&gt;NonKeyAttributes&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ALL&lt;/code&gt; - All of the table attributes are projected into the</span>
    <span class="doccomment">/// index.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NonKeyAttributes&lt;/code&gt; - A list of one or more non-key</span>
    <span class="doccomment">/// attribute names that are projected into the secondary index. The total</span>
    <span class="doccomment">/// count of attributes provided in &lt;code&gt;NonKeyAttributes&lt;/code&gt;,</span>
    <span class="doccomment">/// summed across all of the secondary indexes, must not exceed 100. If you</span>
    <span class="doccomment">/// project the same attribute into two different indexes, this counts as</span>
    <span class="doccomment">/// two distinct attributes when determining the total.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">local_secondary_indexes</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::LocalSecondaryIndex</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;One or more global secondary indexes (the maximum is 20) to be created on the table. Each global secondary index in the array includes the following:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;IndexName&lt;/code&gt; - The name of the global secondary index. Must be unique only for this table.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;KeySchema&lt;/code&gt; - Specifies the key schema for the global secondary index.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Projection&lt;/code&gt; - Specifies</span>
    <span class="doccomment">/// attributes that are copied (projected) from the table into the index. These are in</span>
    <span class="doccomment">/// addition to the primary key attributes and index key</span>
    <span class="doccomment">/// attributes, which are automatically projected. Each</span>
    <span class="doccomment">/// attribute specification is composed of:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ProjectionType&lt;/code&gt; - One</span>
    <span class="doccomment">/// of the following:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;KEYS_ONLY&lt;/code&gt; - Only the index and primary keys are projected into the</span>
    <span class="doccomment">/// index.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;INCLUDE&lt;/code&gt; - Only the specified table attributes are</span>
    <span class="doccomment">/// projected into the index. The list of projected attributes is in</span>
    <span class="doccomment">/// &lt;code&gt;NonKeyAttributes&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ALL&lt;/code&gt; - All of the table attributes are projected into the</span>
    <span class="doccomment">/// index.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NonKeyAttributes&lt;/code&gt; - A list of one or more non-key attribute names that are</span>
    <span class="doccomment">/// projected into the secondary index. The total count of attributes provided in &lt;code&gt;NonKeyAttributes&lt;/code&gt;, summed across all of the secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ProvisionedThroughput&lt;/code&gt; - The provisioned throughput settings for the global secondary index,</span>
    <span class="doccomment">/// consisting of read and write capacity units.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_secondary_indexes</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::GlobalSecondaryIndex</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Controls how you are charged for read and write throughput and how you manage capacity. This setting can be changed later.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;PROVISIONED&lt;/code&gt; - We recommend using &lt;code&gt;PROVISIONED&lt;/code&gt; for predictable workloads. &lt;code&gt;PROVISIONED&lt;/code&gt; sets the billing mode to &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual&quot;&gt;Provisioned Mode&lt;/a&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; - We recommend using &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; for unpredictable workloads. &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; sets the billing mode to &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand&quot;&gt;On-Demand Mode&lt;/a&gt;.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">billing_mode</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::BillingMode</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Represents the provisioned throughput settings for a specified table or index. The</span>
    <span class="doccomment">/// settings can be modified using the &lt;code&gt;UpdateTable&lt;/code&gt; operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt; If you set BillingMode as &lt;code&gt;PROVISIONED&lt;/code&gt;, you must specify this property. If you</span>
    <span class="doccomment">/// set BillingMode as &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt;, you cannot specify this</span>
    <span class="doccomment">/// property.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For current minimum and maximum provisioned throughput values, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html&quot;&gt;Service,</span>
    <span class="doccomment">/// Account, and Table Quotas&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">provisioned_throughput</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ProvisionedThroughput</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The settings for DynamoDB Streams on the table. These settings consist of:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;StreamEnabled&lt;/code&gt; - Indicates whether DynamoDB Streams is to be enabled</span>
    <span class="doccomment">/// (true) or disabled (false).&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;StreamViewType&lt;/code&gt; - When an item in the table is modified, &lt;code&gt;StreamViewType&lt;/code&gt;</span>
    <span class="doccomment">/// determines what information is written to the table&#39;s stream. Valid values for</span>
    <span class="doccomment">/// &lt;code&gt;StreamViewType&lt;/code&gt; are:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;KEYS_ONLY&lt;/code&gt; - Only the key attributes of the modified item are written to the</span>
    <span class="doccomment">/// stream.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NEW_IMAGE&lt;/code&gt; - The entire item, as it appears after it was modified, is written</span>
    <span class="doccomment">/// to the stream.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;OLD_IMAGE&lt;/code&gt; - The entire item, as it appeared before it was modified, is</span>
    <span class="doccomment">/// written to the stream.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NEW_AND_OLD_IMAGES&lt;/code&gt; - Both the new and the old item images of the item are</span>
    <span class="doccomment">/// written to the stream.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">stream_specification</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::StreamSpecification</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Represents the settings used to enable server-side encryption.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">sse_specification</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::SSESpecification</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A list of key-value pairs to label the table. For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html&quot;&gt;Tagging for DynamoDB&lt;/a&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">tags</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::Tag</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">CreateTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;CreateTableInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;attribute_definitions&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">attribute_definitions</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;key_schema&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">key_schema</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;local_secondary_indexes&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">local_secondary_indexes</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;global_secondary_indexes&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_secondary_indexes</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;billing_mode&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">billing_mode</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;provisioned_throughput&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">provisioned_throughput</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;stream_specification&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">stream_specification</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;sse_specification&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">sse_specification</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;tags&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">tags</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DeleteBackupInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The ARN associated with the backup.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">backup_arn</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DeleteBackupInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DeleteBackupInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;backup_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">backup_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of a &lt;code&gt;DeleteItem&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DeleteItemInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table from which to delete the item.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A map of attribute names to &lt;code&gt;AttributeValue&lt;/code&gt; objects, representing the primary key of</span>
    <span class="doccomment">/// the item to delete.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For the primary key, you must provide all of the attributes. For example, with a simple primary key, you only need to provide a value for the partition key. For a composite primary key, you must provide values for both the partition key and the sort key.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">key</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;ConditionExpression&lt;/code&gt; instead.  For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html&quot;&gt;Expected&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expected</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::ExpectedAttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;ConditionExpression&lt;/code&gt; instead.  For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html&quot;&gt;ConditionalOperator&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">conditional_operator</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConditionalOperator</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Use &lt;code&gt;ReturnValues&lt;/code&gt; if you want to get the item attributes as they appeared before they</span>
    <span class="doccomment">/// were deleted. For &lt;code&gt;DeleteItem&lt;/code&gt;, the valid values are:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt; - If &lt;code&gt;ReturnValues&lt;/code&gt; is not specified, or if its value is</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt;, then nothing is returned. (This setting is the default for</span>
    <span class="doccomment">/// &lt;code&gt;ReturnValues&lt;/code&gt;.)&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ALL_OLD&lt;/code&gt; - The content of the old item is returned.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The &lt;code&gt;ReturnValues&lt;/code&gt; parameter is used by several DynamoDB operations; however,</span>
    <span class="doccomment">/// &lt;code&gt;DeleteItem&lt;/code&gt; does not recognize any values other than &lt;code&gt;NONE&lt;/code&gt; or</span>
    <span class="doccomment">/// &lt;code&gt;ALL_OLD&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_values</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnValue</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines the level of detail about provisioned throughput consumption that is returned in the response:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;INDEXES&lt;/code&gt; - The response includes the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation, together with &lt;code&gt;ConsumedCapacity&lt;/code&gt; for each table and secondary index that was accessed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Note that some operations, such as &lt;code&gt;GetItem&lt;/code&gt; and &lt;code&gt;BatchGetItem&lt;/code&gt;, do not access any indexes at all.  In these cases, specifying &lt;code&gt;INDEXES&lt;/code&gt; will only return &lt;code&gt;ConsumedCapacity&lt;/code&gt; information for table(s).&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;TOTAL&lt;/code&gt; - The response includes only the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt; - No &lt;code&gt;ConsumedCapacity&lt;/code&gt; details are included in the response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_consumed_capacity</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnConsumedCapacity</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines whether item collection metrics are returned.  If set to &lt;code&gt;SIZE&lt;/code&gt;, the response includes statistics about item collections, if any, that were modified during</span>
    <span class="doccomment">/// the operation are returned in the response. If set to &lt;code&gt;NONE&lt;/code&gt; (the default), no statistics are returned.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_item_collection_metrics</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnItemCollectionMetrics</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A condition that must be satisfied in order for a conditional &lt;code&gt;DeleteItem&lt;/code&gt; to</span>
    <span class="doccomment">/// succeed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;An expression can contain any of the following:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Functions: &lt;code&gt;attribute_exists | attribute_not_exists | attribute_type | contains | begins_with | size&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;These function names are case-sensitive.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Comparison operators: &lt;code&gt;= | &lt;&gt; |</span>
    <span class="doccomment">/// &lt; | &gt; | &lt;= | &gt;= |</span>
    <span class="doccomment">/// BETWEEN | IN &lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt; Logical operators: &lt;code&gt;AND | OR | NOT&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information about condition expressions, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html&quot;&gt;Condition Expressions&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">condition_expression</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;One or more substitution tokens for attribute names in an expression. The following are some use cases for using &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To access an attribute whose name conflicts with a DynamoDB reserved word.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To create a placeholder for repeating occurrences of an attribute name in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To prevent special characters in an attribute name from being misinterpreted in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Use the &lt;b&gt;#&lt;/b&gt; character in an expression to dereference an attribute name. For example, consider the following attribute name:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Percentile&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The name of this attribute conflicts with a reserved word, so it cannot be used directly in an expression. (For the complete list of reserved words, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html&quot;&gt;Reserved Words&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;). To work around this, you could specify the following for &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;{&quot;#P&quot;:&quot;Percentile&quot;}&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You could then use this substitution in an expression, as in this example:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;#P = :val&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Tokens that begin with the &lt;b&gt;:&lt;/b&gt; character are &lt;i&gt;expression attribute values&lt;/i&gt;, which are placeholders for the actual value at runtime.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information on expression attribute names, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html&quot;&gt;Specifying Item Attributes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expression_attribute_names</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;One or more values that can be substituted in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Use the &lt;b&gt;:&lt;/b&gt; (colon) character in an expression to dereference an attribute value. For example, suppose that you wanted to check whether the value of the &lt;i&gt;ProductStatus&lt;/i&gt; attribute was one of the following: &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Available | Backordered | Discontinued&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You would first need to specify &lt;code&gt;ExpressionAttributeValues&lt;/code&gt; as follows:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;{ &quot;:avail&quot;:{&quot;S&quot;:&quot;Available&quot;}, &quot;:back&quot;:{&quot;S&quot;:&quot;Backordered&quot;}, &quot;:disc&quot;:{&quot;S&quot;:&quot;Discontinued&quot;} }&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You could then use these values in an expression, such as this:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ProductStatus IN (:avail, :back, :disc)&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information on expression attribute values, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html&quot;&gt;Condition Expressions&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expression_attribute_values</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DeleteItemInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DeleteItemInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;key&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">key</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;expected&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expected</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;conditional_operator&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">conditional_operator</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;return_values&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_values</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;return_consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;return_item_collection_metrics&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_item_collection_metrics</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;condition_expression&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">condition_expression</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;expression_attribute_names&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expression_attribute_names</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;expression_attribute_values&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expression_attribute_values</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of a &lt;code&gt;DeleteTable&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DeleteTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table to delete.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DeleteTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DeleteTableInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeBackupInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The Amazon Resource Name (ARN) associated with the backup.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">backup_arn</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeBackupInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeBackupInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;backup_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">backup_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeContinuousBackupsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;Name of the table for which the customer wants to check the continuous backups and point in time recovery settings.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeContinuousBackupsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeContinuousBackupsInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeContributorInsightsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table to describe.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The name of the global secondary index to describe, if applicable.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">index_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeContributorInsightsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeContributorInsightsInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;index_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">index_name</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeExportInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The Amazon Resource Name (ARN) associated with the export.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">export_arn</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeExportInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeExportInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;export_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">export_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeGlobalTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the global table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeGlobalTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeGlobalTableInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;global_table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeGlobalTableSettingsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the global table to describe.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeGlobalTableSettingsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeGlobalTableSettingsInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;global_table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeKinesisStreamingDestinationInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table being described.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeKinesisStreamingDestinationInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeKinesisStreamingDestinationInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of a &lt;code&gt;DescribeTable&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table to describe.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeTableInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeTableReplicaAutoScalingInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeTableReplicaAutoScalingInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeTableReplicaAutoScalingInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeTimeToLiveInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table to be described.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeTimeToLiveInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeTimeToLiveInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DisableKinesisStreamingDestinationInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the DynamoDB table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The ARN for a Kinesis data stream.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">stream_arn</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DisableKinesisStreamingDestinationInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DisableKinesisStreamingDestinationInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;stream_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">stream_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">EnableKinesisStreamingDestinationInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the DynamoDB table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The ARN for a Kinesis data stream.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">stream_arn</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">EnableKinesisStreamingDestinationInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;EnableKinesisStreamingDestinationInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;stream_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">stream_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ExecuteStatementInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// The PartiQL statement representing the operation to run.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">statement</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// The parameters for the PartiQL statement, if any.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">parameters</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// The consistency of a read operation. If set to &lt;code&gt;true&lt;/code&gt;, then a strongly consistent read is used; otherwise, an eventually consistent read is used.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">consistent_read</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// Set this value to get remaining results, if &lt;code&gt;NextToken&lt;/code&gt; was returned in the statement response.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">next_token</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ExecuteStatementInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ExecuteStatementInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;statement&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">statement</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;parameters&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">parameters</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consistent_read&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consistent_read</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;next_token&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">next_token</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ExecuteTransactionInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// The list of PartiQL statements representing the transaction to run.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">transact_statements</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ParameterizedStatement</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// Set this value to get remaining results, if &lt;code&gt;NextToken&lt;/code&gt; was returned in the statement response.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">client_request_token</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ExecuteTransactionInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ExecuteTransactionInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;transact_statements&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">transact_statements</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;client_request_token&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">client_request_token</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ExportTableToPointInTimeInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The Amazon Resource Name (ARN) associated with the table to export.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_arn</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Time in the past from which to export table data. The table export will be a snapshot</span>
    <span class="doccomment">/// of the table&#39;s state at this point in time.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">export_time</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">smithy_types::Instant</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Providing a &lt;code&gt;ClientToken&lt;/code&gt; makes the call to</span>
    <span class="doccomment">/// &lt;code&gt;ExportTableToPointInTimeInput&lt;/code&gt; idempotent, meaning that multiple</span>
    <span class="doccomment">/// identical calls have the same effect as one single call.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;A client token is valid for 8 hours after the first request that uses it is</span>
    <span class="doccomment">/// completed. After 8 hours, any request with the same client token is treated as a new</span>
    <span class="doccomment">/// request. Do not resubmit the same request with the same client token for more than 8</span>
    <span class="doccomment">/// hours, or the result might not be idempotent.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you submit a request with the same client token but a change in other parameters</span>
    <span class="doccomment">/// within the 8-hour idempotency window, DynamoDB returns an</span>
    <span class="doccomment">/// &lt;code&gt;IdempotentParameterMismatch&lt;/code&gt; exception.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">client_token</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The name of the Amazon S3 bucket to export the snapshot to.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">s3_bucket</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The ID of the AWS account that owns the bucket the export will be stored in.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">s3_bucket_owner</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The Amazon S3 bucket prefix to use as the file name and path of the exported</span>
    <span class="doccomment">/// snapshot.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">s3_prefix</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Type of encryption used on the bucket where export data will be stored. Valid values</span>
    <span class="doccomment">/// for &lt;code&gt;S3SseAlgorithm&lt;/code&gt; are:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;AES256&lt;/code&gt; - server-side encryption with Amazon S3 managed keys&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;KMS&lt;/code&gt; - server-side encryption with AWS KMS managed keys&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">s3_sse_algorithm</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::S3SseAlgorithm</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The ID of the AWS KMS managed key used to encrypt the S3 bucket where export data will</span>
    <span class="doccomment">/// be stored (if applicable).&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">s3_sse_kms_key_id</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The format for the exported data. Valid values for &lt;code&gt;ExportFormat&lt;/code&gt; are</span>
    <span class="doccomment">/// &lt;code&gt;DYNAMODB_JSON&lt;/code&gt; or &lt;code&gt;ION&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">export_format</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ExportFormat</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ExportTableToPointInTimeInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ExportTableToPointInTimeInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;export_time&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">export_time</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;client_token&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">client_token</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;s3_bucket&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">s3_bucket</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;s3_bucket_owner&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">s3_bucket_owner</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;s3_prefix&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">s3_prefix</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;s3_sse_algorithm&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">s3_sse_algorithm</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;s3_sse_kms_key_id&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">s3_sse_kms_key_id</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;export_format&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">export_format</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of a &lt;code&gt;GetItem&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">GetItemInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table containing the requested item.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A map of attribute names to &lt;code&gt;AttributeValue&lt;/code&gt; objects, representing the primary key of</span>
    <span class="doccomment">/// the item to retrieve.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For the primary key, you must provide all of the attributes. For example, with a simple primary key, you only need to provide a value for the partition key. For a composite primary key, you must provide values for both the partition key and the sort key.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">key</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;ProjectionExpression&lt;/code&gt; instead.  For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html&quot;&gt;AttributesToGet&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">attributes_to_get</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines the read consistency model:  If set to &lt;code&gt;true&lt;/code&gt;, then the operation uses strongly consistent reads; otherwise, the operation uses eventually consistent reads.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">consistent_read</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines the level of detail about provisioned throughput consumption that is returned in the response:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;INDEXES&lt;/code&gt; - The response includes the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation, together with &lt;code&gt;ConsumedCapacity&lt;/code&gt; for each table and secondary index that was accessed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Note that some operations, such as &lt;code&gt;GetItem&lt;/code&gt; and &lt;code&gt;BatchGetItem&lt;/code&gt;, do not access any indexes at all.  In these cases, specifying &lt;code&gt;INDEXES&lt;/code&gt; will only return &lt;code&gt;ConsumedCapacity&lt;/code&gt; information for table(s).&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;TOTAL&lt;/code&gt; - The response includes only the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt; - No &lt;code&gt;ConsumedCapacity&lt;/code&gt; details are included in the response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_consumed_capacity</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnConsumedCapacity</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A string that identifies one or more attributes to retrieve from the table. These attributes can include scalars, sets, or elements of a JSON document. The attributes in the expression must be separated by commas.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If no attribute names are specified, then all attributes are returned. If any of the</span>
    <span class="doccomment">/// requested attributes are not found, they do not appear in the result.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html&quot;&gt;Specifying Item Attributes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">projection_expression</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;One or more substitution tokens for attribute names in an expression. The following are some use cases for using &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To access an attribute whose name conflicts with a DynamoDB reserved word.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To create a placeholder for repeating occurrences of an attribute name in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To prevent special characters in an attribute name from being misinterpreted in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Use the &lt;b&gt;#&lt;/b&gt; character in an expression to dereference an attribute name. For example, consider the following attribute name:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Percentile&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The name of this attribute conflicts with a reserved word, so it cannot be used directly in an expression. (For the complete list of reserved words, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html&quot;&gt;Reserved Words&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;). To work around this, you could specify the following for &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;{&quot;#P&quot;:&quot;Percentile&quot;}&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You could then use this substitution in an expression, as in this example:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;#P = :val&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Tokens that begin with the &lt;b&gt;:&lt;/b&gt; character are &lt;i&gt;expression attribute values&lt;/i&gt;, which are placeholders for the actual value at runtime.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information on expression attribute names, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html&quot;&gt;Specifying Item Attributes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expression_attribute_names</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">GetItemInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;GetItemInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;key&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">key</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;attributes_to_get&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">attributes_to_get</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consistent_read&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consistent_read</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;return_consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;projection_expression&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">projection_expression</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;expression_attribute_names&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expression_attribute_names</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ListBackupsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The backups from the table specified by &lt;code&gt;TableName&lt;/code&gt; are listed. &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Maximum number of backups to return at once.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">limit</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Only backups created after this time are listed. &lt;code&gt;TimeRangeLowerBound&lt;/code&gt; is inclusive.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">time_range_lower_bound</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">smithy_types::Instant</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Only backups created before this time are listed. &lt;code&gt;TimeRangeUpperBound&lt;/code&gt; is exclusive. &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">time_range_upper_bound</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">smithy_types::Instant</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;LastEvaluatedBackupArn&lt;/code&gt; is the Amazon Resource Name (ARN) of the backup last</span>
    <span class="doccomment">/// evaluated when the current page of results was returned, inclusive of the current page</span>
    <span class="doccomment">/// of results. This value may be specified as the &lt;code&gt;ExclusiveStartBackupArn&lt;/code&gt; of a</span>
    <span class="doccomment">/// new &lt;code&gt;ListBackups&lt;/code&gt; operation in order to fetch the next page of results. &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">exclusive_start_backup_arn</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The backups from the table specified by &lt;code&gt;BackupType&lt;/code&gt; are listed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Where &lt;code&gt;BackupType&lt;/code&gt; can be:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;USER&lt;/code&gt; - On-demand backup created by you.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;SYSTEM&lt;/code&gt; - On-demand backup automatically created by</span>
    <span class="doccomment">/// DynamoDB.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ALL&lt;/code&gt; - All types of on-demand backups (USER and SYSTEM).&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">backup_type</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::BackupTypeFilter</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ListBackupsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ListBackupsInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;limit&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">limit</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;time_range_lower_bound&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">time_range_lower_bound</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;time_range_upper_bound&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">time_range_upper_bound</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;exclusive_start_backup_arn&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">exclusive_start_backup_arn</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;backup_type&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">backup_type</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ListContributorInsightsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A token to for the desired page, if there is one.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">next_token</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Maximum number of results to return per page.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">max_results</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">i32</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ListContributorInsightsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ListContributorInsightsInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;next_token&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">next_token</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;max_results&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">max_results</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ListExportsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The Amazon Resource Name (ARN) associated with the exported table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_arn</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Maximum number of results to return per page.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">max_results</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;An optional string that, if supplied, must be copied from the output of a previous</span>
    <span class="doccomment">/// call to &lt;code&gt;ListExports&lt;/code&gt;. When provided in this manner, the API fetches the next</span>
    <span class="doccomment">/// page of results.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">next_token</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ListExportsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ListExportsInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;max_results&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">max_results</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;next_token&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">next_token</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ListGlobalTablesInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The first global table name that this operation will evaluate.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">exclusive_start_global_table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The maximum number of table names to return, if the parameter is not specified DynamoDB defaults to 100.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If the number of global tables DynamoDB finds reaches this limit, it stops the operation and returns the table names collected up to that point,</span>
    <span class="doccomment">/// with a table name in the &lt;code&gt;LastEvaluatedGlobalTableName&lt;/code&gt; to apply in a subsequent operation to the &lt;code&gt;ExclusiveStartGlobalTableName&lt;/code&gt; parameter.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">limit</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Lists the global tables in a specific Region.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">region_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ListGlobalTablesInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ListGlobalTablesInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;exclusive_start_global_table_name&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">exclusive_start_global_table_name</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;limit&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">limit</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;region_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">region_name</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of a &lt;code&gt;ListTables&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ListTablesInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The first table name that this operation will evaluate. Use the value that was returned for</span>
    <span class="doccomment">/// &lt;code&gt;LastEvaluatedTableName&lt;/code&gt; in a previous operation, so that you can obtain the next page</span>
    <span class="doccomment">/// of results.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">exclusive_start_table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A maximum number of table names to return. If this parameter is not specified, the limit is 100.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">limit</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ListTablesInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ListTablesInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;exclusive_start_table_name&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">exclusive_start_table_name</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;limit&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">limit</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ListTagsOfResourceInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The Amazon DynamoDB resource with tags to be listed. This value is an Amazon Resource Name (ARN).&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">resource_arn</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;An optional string that, if supplied, must be copied from the output of a previous</span>
    <span class="doccomment">/// call to ListTagOfResource. When provided in this manner, this API fetches the next page of results.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">next_token</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ListTagsOfResourceInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ListTagsOfResourceInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;resource_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">resource_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;next_token&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">next_token</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of a &lt;code&gt;PutItem&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">PutItemInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table to contain the item.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A map of attribute name/value pairs, one for each attribute. Only the primary key attributes are required; you can optionally provide other attribute name-value pairs for the item.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You must provide all of the attributes for the primary key. For example, with a simple primary key, you only need to provide a value for the partition key. For a composite primary key, you must provide both values for both the partition key and the sort key.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you specify any attributes that are part of an index key, then the data types for those attributes must match those of the schema in the table&#39;s attribute definition.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Empty String and Binary attribute values are allowed. Attribute values of type String and Binary must have a length greater than zero if the attribute is used as a key attribute for a table or index.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information about primary keys, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey&quot;&gt;Primary Key&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Each element in the &lt;code&gt;Item&lt;/code&gt; map is an &lt;code&gt;AttributeValue&lt;/code&gt; object.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">item</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;ConditionExpression&lt;/code&gt; instead.  For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html&quot;&gt;Expected&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expected</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::ExpectedAttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Use &lt;code&gt;ReturnValues&lt;/code&gt; if you want to get the item attributes as they appeared before they</span>
    <span class="doccomment">/// were updated with the &lt;code&gt;PutItem&lt;/code&gt; request. For &lt;code&gt;PutItem&lt;/code&gt;, the valid values are:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt; - If &lt;code&gt;ReturnValues&lt;/code&gt; is not specified, or if its value is</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt;, then nothing is returned. (This setting is the default for</span>
    <span class="doccomment">/// &lt;code&gt;ReturnValues&lt;/code&gt;.)&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ALL_OLD&lt;/code&gt; - If &lt;code&gt;PutItem&lt;/code&gt; overwrote an attribute name-value pair, then the</span>
    <span class="doccomment">/// content of the old item is returned.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The &lt;code&gt;ReturnValues&lt;/code&gt; parameter is used by several DynamoDB operations; however,</span>
    <span class="doccomment">/// &lt;code&gt;PutItem&lt;/code&gt; does not recognize any values other than &lt;code&gt;NONE&lt;/code&gt; or</span>
    <span class="doccomment">/// &lt;code&gt;ALL_OLD&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_values</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnValue</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines the level of detail about provisioned throughput consumption that is returned in the response:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;INDEXES&lt;/code&gt; - The response includes the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation, together with &lt;code&gt;ConsumedCapacity&lt;/code&gt; for each table and secondary index that was accessed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Note that some operations, such as &lt;code&gt;GetItem&lt;/code&gt; and &lt;code&gt;BatchGetItem&lt;/code&gt;, do not access any indexes at all.  In these cases, specifying &lt;code&gt;INDEXES&lt;/code&gt; will only return &lt;code&gt;ConsumedCapacity&lt;/code&gt; information for table(s).&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;TOTAL&lt;/code&gt; - The response includes only the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt; - No &lt;code&gt;ConsumedCapacity&lt;/code&gt; details are included in the response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_consumed_capacity</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnConsumedCapacity</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines whether item collection metrics are returned.  If set to &lt;code&gt;SIZE&lt;/code&gt;, the response includes statistics about item collections, if any, that were modified during</span>
    <span class="doccomment">/// the operation are returned in the response. If set to &lt;code&gt;NONE&lt;/code&gt; (the default), no statistics are returned.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_item_collection_metrics</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnItemCollectionMetrics</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;ConditionExpression&lt;/code&gt; instead.  For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html&quot;&gt;ConditionalOperator&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">conditional_operator</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConditionalOperator</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A condition that must be satisfied in order for a conditional &lt;code&gt;PutItem&lt;/code&gt; operation to</span>
    <span class="doccomment">/// succeed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;An expression can contain any of the following:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Functions: &lt;code&gt;attribute_exists | attribute_not_exists | attribute_type | contains | begins_with | size&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;These function names are case-sensitive.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Comparison operators: &lt;code&gt;= | &lt;&gt; |</span>
    <span class="doccomment">/// &lt; | &gt; | &lt;= | &gt;= |</span>
    <span class="doccomment">/// BETWEEN | IN &lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt; Logical operators: &lt;code&gt;AND | OR | NOT&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information on condition expressions, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html&quot;&gt;Condition Expressions&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">condition_expression</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;One or more substitution tokens for attribute names in an expression. The following are some use cases for using &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To access an attribute whose name conflicts with a DynamoDB reserved word.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To create a placeholder for repeating occurrences of an attribute name in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To prevent special characters in an attribute name from being misinterpreted in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Use the &lt;b&gt;#&lt;/b&gt; character in an expression to dereference an attribute name. For example, consider the following attribute name:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Percentile&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The name of this attribute conflicts with a reserved word, so it cannot be used directly in an expression. (For the complete list of reserved words, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html&quot;&gt;Reserved Words&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;). To work around this, you could specify the following for &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;{&quot;#P&quot;:&quot;Percentile&quot;}&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You could then use this substitution in an expression, as in this example:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;#P = :val&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Tokens that begin with the &lt;b&gt;:&lt;/b&gt; character are &lt;i&gt;expression attribute values&lt;/i&gt;, which are placeholders for the actual value at runtime.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information on expression attribute names, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html&quot;&gt;Specifying Item Attributes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expression_attribute_names</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;One or more values that can be substituted in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Use the &lt;b&gt;:&lt;/b&gt; (colon) character in an expression to dereference an attribute value. For example, suppose that you wanted to check whether the value of the &lt;i&gt;ProductStatus&lt;/i&gt; attribute was one of the following: &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Available | Backordered | Discontinued&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You would first need to specify &lt;code&gt;ExpressionAttributeValues&lt;/code&gt; as follows:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;{ &quot;:avail&quot;:{&quot;S&quot;:&quot;Available&quot;}, &quot;:back&quot;:{&quot;S&quot;:&quot;Backordered&quot;}, &quot;:disc&quot;:{&quot;S&quot;:&quot;Discontinued&quot;} }&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You could then use these values in an expression, such as this:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ProductStatus IN (:avail, :back, :disc)&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information on expression attribute values, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html&quot;&gt;Condition Expressions&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expression_attribute_values</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">PutItemInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;PutItemInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;item&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">item</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;expected&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expected</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;return_values&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_values</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;return_consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;return_item_collection_metrics&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_item_collection_metrics</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;conditional_operator&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">conditional_operator</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;condition_expression&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">condition_expression</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;expression_attribute_names&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expression_attribute_names</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;expression_attribute_values&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expression_attribute_values</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of a &lt;code&gt;Query&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">QueryInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table containing the requested items.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The name of an index to query. This index can be any local secondary index or global secondary index on the table. Note that</span>
    <span class="doccomment">/// if you use the &lt;code&gt;IndexName&lt;/code&gt; parameter, you must also provide &lt;code&gt;TableName.&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">index_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The attributes to be returned in the</span>
    <span class="doccomment">/// result. You can retrieve all item attributes, specific item attributes, the count of</span>
    <span class="doccomment">/// matching items, or in the case of an index, some or all of the attributes projected into</span>
    <span class="doccomment">/// the index.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ALL_ATTRIBUTES&lt;/code&gt; - Returns all of the item attributes from the</span>
    <span class="doccomment">/// specified table or index. If you query a local secondary index, then for each</span>
    <span class="doccomment">/// matching item in the index, DynamoDB fetches the entire item from the parent</span>
    <span class="doccomment">/// table. If the index is configured to project all item attributes, then all of</span>
    <span class="doccomment">/// the data can be obtained from the local secondary index, and no fetching is</span>
    <span class="doccomment">/// required.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ALL_PROJECTED_ATTRIBUTES&lt;/code&gt; - Allowed only when querying an index.</span>
    <span class="doccomment">/// Retrieves all attributes that have been projected into the index. If the</span>
    <span class="doccomment">/// index is configured to project all attributes, this return value is</span>
    <span class="doccomment">/// equivalent to specifying &lt;code&gt;ALL_ATTRIBUTES&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;COUNT&lt;/code&gt; - Returns the number of matching items, rather than the</span>
    <span class="doccomment">/// matching items themselves.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;SPECIFIC_ATTRIBUTES&lt;/code&gt; - Returns only the attributes listed in</span>
    <span class="doccomment">/// &lt;code&gt;AttributesToGet&lt;/code&gt;. This return value is equivalent to</span>
    <span class="doccomment">/// specifying &lt;code&gt;AttributesToGet&lt;/code&gt; without specifying any value</span>
    <span class="doccomment">/// for &lt;code&gt;Select&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you query or scan a local secondary index and request only attributes that</span>
    <span class="doccomment">/// are projected into that index, the operation will read only the index and not</span>
    <span class="doccomment">/// the table. If any of the requested attributes are not projected into the local</span>
    <span class="doccomment">/// secondary index, DynamoDB fetches each of these attributes from the parent</span>
    <span class="doccomment">/// table. This extra fetching incurs additional throughput cost and latency.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you query or scan a global secondary index, you can only request</span>
    <span class="doccomment">/// attributes that are projected into the index. Global secondary index queries</span>
    <span class="doccomment">/// cannot fetch attributes from the parent table.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If neither &lt;code&gt;Select&lt;/code&gt; nor &lt;code&gt;AttributesToGet&lt;/code&gt;</span>
    <span class="doccomment">/// are specified, DynamoDB defaults to &lt;code&gt;ALL_ATTRIBUTES&lt;/code&gt; when accessing a</span>
    <span class="doccomment">/// table, and &lt;code&gt;ALL_PROJECTED_ATTRIBUTES&lt;/code&gt; when accessing an index. You cannot</span>
    <span class="doccomment">/// use both &lt;code&gt;Select&lt;/code&gt; and &lt;code&gt;AttributesToGet&lt;/code&gt;</span>
    <span class="doccomment">/// together in a single request, unless the value for &lt;code&gt;Select&lt;/code&gt; is</span>
    <span class="doccomment">/// &lt;code&gt;SPECIFIC_ATTRIBUTES&lt;/code&gt;. (This usage is equivalent to specifying</span>
    <span class="doccomment">/// &lt;code&gt;AttributesToGet&lt;/code&gt; without any value for</span>
    <span class="doccomment">/// &lt;code&gt;Select&lt;/code&gt;.)&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you use the &lt;code&gt;ProjectionExpression&lt;/code&gt; parameter, then</span>
    <span class="doccomment">/// the value for &lt;code&gt;Select&lt;/code&gt; can only be</span>
    <span class="doccomment">/// &lt;code&gt;SPECIFIC_ATTRIBUTES&lt;/code&gt;. Any other value for</span>
    <span class="doccomment">/// &lt;code&gt;Select&lt;/code&gt; will return an error.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="kw">pub</span> <span class="ident">select</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::Select</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;ProjectionExpression&lt;/code&gt; instead.  For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html&quot;&gt;AttributesToGet&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">attributes_to_get</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The maximum number of items to evaluate (not necessarily the number of matching items).</span>
    <span class="doccomment">/// If DynamoDB processes the number of items up to the limit while processing the results,</span>
    <span class="doccomment">/// it stops the operation and returns the matching values up to that point, and a key in</span>
    <span class="doccomment">/// &lt;code&gt;LastEvaluatedKey&lt;/code&gt; to apply in a subsequent operation, so that you can</span>
    <span class="doccomment">/// pick up where you left off. Also, if the processed dataset size exceeds 1 MB before</span>
    <span class="doccomment">/// DynamoDB reaches this limit, it stops the operation and returns the matching values up</span>
    <span class="doccomment">/// to the limit, and a key in &lt;code&gt;LastEvaluatedKey&lt;/code&gt; to apply in a subsequent</span>
    <span class="doccomment">/// operation to continue the operation. For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html&quot;&gt;Query and Scan&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">limit</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines the read consistency model:  If set to &lt;code&gt;true&lt;/code&gt;, then the operation uses strongly consistent reads; otherwise, the operation uses eventually consistent reads.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Strongly consistent reads</span>
    <span class="doccomment">/// are not supported on global secondary indexes. If you query a global secondary index with &lt;code&gt;ConsistentRead&lt;/code&gt; set to</span>
    <span class="doccomment">/// &lt;code&gt;true&lt;/code&gt;, you will receive a &lt;code&gt;ValidationException&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">consistent_read</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;KeyConditionExpression&lt;/code&gt; instead.   For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.KeyConditions.html&quot;&gt;KeyConditions&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">key_conditions</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::Condition</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;FilterExpression&lt;/code&gt; instead.   For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.QueryFilter.html&quot;&gt;QueryFilter&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">query_filter</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::Condition</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;FilterExpression&lt;/code&gt; instead.  For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html&quot;&gt;ConditionalOperator&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">conditional_operator</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConditionalOperator</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Specifies the order for index traversal: If &lt;code&gt;true&lt;/code&gt; (default), the traversal is performed in ascending order; if &lt;code&gt;false&lt;/code&gt;, the traversal is performed in descending order. &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Items with the same partition key value are stored in sorted order by sort key. If the sort key data type is Number, the results are stored in numeric order. For type String, the results are stored in order of UTF-8 bytes. For type Binary, DynamoDB treats each byte of the binary data as unsigned.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If &lt;code&gt;ScanIndexForward&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, DynamoDB returns the results in the order in which they are stored (by sort key value). This is the default behavior. If &lt;code&gt;ScanIndexForward&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, DynamoDB reads the results in reverse order by sort key value, and then returns the results to the client.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">scan_index_forward</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The primary key of the first item that this operation will evaluate. Use the value that was returned for &lt;code&gt;LastEvaluatedKey&lt;/code&gt; in the previous operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The data type for &lt;code&gt;ExclusiveStartKey&lt;/code&gt; must be String, Number, or Binary. No</span>
    <span class="doccomment">/// set data types are allowed.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">exclusive_start_key</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines the level of detail about provisioned throughput consumption that is returned in the response:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;INDEXES&lt;/code&gt; - The response includes the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation, together with &lt;code&gt;ConsumedCapacity&lt;/code&gt; for each table and secondary index that was accessed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Note that some operations, such as &lt;code&gt;GetItem&lt;/code&gt; and &lt;code&gt;BatchGetItem&lt;/code&gt;, do not access any indexes at all.  In these cases, specifying &lt;code&gt;INDEXES&lt;/code&gt; will only return &lt;code&gt;ConsumedCapacity&lt;/code&gt; information for table(s).&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;TOTAL&lt;/code&gt; - The response includes only the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt; - No &lt;code&gt;ConsumedCapacity&lt;/code&gt; details are included in the response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_consumed_capacity</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnConsumedCapacity</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A string that identifies one or more attributes to retrieve from the table. These attributes can include scalars, sets, or elements of a JSON document. The attributes in the expression must be separated by commas.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If no attribute names are specified, then all attributes will be returned. If any of the requested attributes are not found, they will not appear in the result.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html&quot;&gt;Accessing Item Attributes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">projection_expression</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A string that contains conditions that DynamoDB applies after the &lt;code&gt;Query&lt;/code&gt; operation, but</span>
    <span class="doccomment">/// before the data is returned to you. Items that do not satisfy the &lt;code&gt;FilterExpression&lt;/code&gt;</span>
    <span class="doccomment">/// criteria are not returned.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;A &lt;code&gt;FilterExpression&lt;/code&gt; does not allow key attributes.  You cannot define a filter expression based on a partition key or a sort key.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;A &lt;code&gt;FilterExpression&lt;/code&gt; is applied after the items have already been read; the process of</span>
    <span class="doccomment">/// filtering does not consume any additional read capacity units.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#FilteringResults&quot;&gt;Filter</span>
    <span class="doccomment">/// Expressions&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">filter_expression</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The condition that specifies the key values for items to be retrieved by the</span>
    <span class="doccomment">/// &lt;code&gt;Query&lt;/code&gt; action.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The condition must perform an equality test on a single partition key value.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The condition can optionally perform one of several comparison tests on a single</span>
    <span class="doccomment">/// sort key value. This allows &lt;code&gt;Query&lt;/code&gt; to retrieve one item with a given</span>
    <span class="doccomment">/// partition key value and sort key value, or several items that have the same partition</span>
    <span class="doccomment">/// key value but different sort key values.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The partition key equality test is required, and must be specified in the following format:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;partitionKeyName&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;i&gt;=&lt;/i&gt;</span>
    <span class="doccomment">/// &lt;code&gt;:partitionkeyval&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you also want to provide a condition for the sort key, it must be combined using &lt;code&gt;AND&lt;/code&gt; with the condition</span>
    <span class="doccomment">/// for the sort key. Following is an example, using the &lt;b&gt;=&lt;/b&gt; comparison operator for the sort key:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;partitionKeyName&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;=&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;:partitionkeyval&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;AND&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;sortKeyName&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;=&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;:sortkeyval&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Valid comparisons for the sort key condition are as follows:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;sortKeyName&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;=&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;:sortkeyval&lt;/code&gt; - true if the sort key value is equal to &lt;code&gt;:sortkeyval&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;sortKeyName&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;&lt;&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;:sortkeyval&lt;/code&gt; - true if the sort key value is less than &lt;code&gt;:sortkeyval&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;sortKeyName&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;&lt;=&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;:sortkeyval&lt;/code&gt; - true if the sort key value is less than or equal to</span>
    <span class="doccomment">/// &lt;code&gt;:sortkeyval&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;sortKeyName&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;&gt;&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;:sortkeyval&lt;/code&gt; - true if the sort key value is greater than &lt;code&gt;:sortkeyval&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;sortKeyName&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;&gt;= &lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;:sortkeyval&lt;/code&gt; - true if the sort key value is greater than</span>
    <span class="doccomment">/// or equal to &lt;code&gt;:sortkeyval&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;sortKeyName&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;BETWEEN&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;:sortkeyval1&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;AND&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;:sortkeyval2&lt;/code&gt; - true if the sort key value is greater than or equal to</span>
    <span class="doccomment">/// &lt;code&gt;:sortkeyval1&lt;/code&gt;, and less than or equal to &lt;code&gt;:sortkeyval2&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;begins_with (&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;sortKeyName&lt;/code&gt;, &lt;code&gt;:sortkeyval&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;code&gt;)&lt;/code&gt; -</span>
    <span class="doccomment">/// true if the sort key value begins with a particular operand. (You cannot use this function with a sort key that is of type Number.)  Note that the function name</span>
    <span class="doccomment">/// &lt;code&gt;begins_with&lt;/code&gt; is case-sensitive.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Use the &lt;code&gt;ExpressionAttributeValues&lt;/code&gt; parameter to replace tokens such as</span>
    <span class="doccomment">/// &lt;code&gt;:partitionval&lt;/code&gt; and &lt;code&gt;:sortval&lt;/code&gt; with actual values at runtime.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You can optionally use the &lt;code&gt;ExpressionAttributeNames&lt;/code&gt; parameter to replace the names of</span>
    <span class="doccomment">/// the partition key and sort key with placeholder tokens. This option might be necessary if an attribute</span>
    <span class="doccomment">/// name conflicts with a DynamoDB reserved word. For example, the following</span>
    <span class="doccomment">/// &lt;code&gt;KeyConditionExpression&lt;/code&gt; parameter causes an error because &lt;i&gt;Size&lt;/i&gt; is a reserved</span>
    <span class="doccomment">/// word:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Size = :myval&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To work around this, define a placeholder (such a &lt;code&gt;#S&lt;/code&gt;) to represent the attribute</span>
    <span class="doccomment">/// name &lt;i&gt;Size&lt;/i&gt;. &lt;code&gt;KeyConditionExpression&lt;/code&gt; then is as follows:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;#S = :myval&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For a list of reserved words, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html&quot;&gt;Reserved</span>
    <span class="doccomment">/// Words&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information on &lt;code&gt;ExpressionAttributeNames&lt;/code&gt; and &lt;code&gt;ExpressionAttributeValues&lt;/code&gt;,</span>
    <span class="doccomment">/// see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ExpressionPlaceholders.html&quot;&gt;Using Placeholders for Attribute</span>
    <span class="doccomment">/// Names and Values&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">key_condition_expression</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;One or more substitution tokens for attribute names in an expression. The following are some use cases for using &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To access an attribute whose name conflicts with a DynamoDB reserved word.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To create a placeholder for repeating occurrences of an attribute name in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To prevent special characters in an attribute name from being misinterpreted in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Use the &lt;b&gt;#&lt;/b&gt; character in an expression to dereference an attribute name. For example, consider the following attribute name:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Percentile&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The name of this attribute conflicts with a reserved word, so it cannot be used directly in an expression. (For the complete list of reserved words, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html&quot;&gt;Reserved Words&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;). To work around this, you could specify the following for</span>
    <span class="doccomment">/// &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;{&quot;#P&quot;:&quot;Percentile&quot;}&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You could then use this substitution in an expression, as in this example:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;#P = :val&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Tokens that begin with the &lt;b&gt;:&lt;/b&gt; character are &lt;i&gt;expression attribute values&lt;/i&gt;, which are placeholders for the actual value at runtime.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information on expression attribute names, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html&quot;&gt;Specifying Item Attributes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expression_attribute_names</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;One or more values that can be substituted in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Use the &lt;b&gt;:&lt;/b&gt; (colon) character in an expression to dereference an attribute value. For example, suppose that you wanted to check whether the value of the</span>
    <span class="doccomment">/// &lt;i&gt;ProductStatus&lt;/i&gt; attribute was one of the following: &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Available | Backordered | Discontinued&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You would first need to specify &lt;code&gt;ExpressionAttributeValues&lt;/code&gt; as follows:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;{ &quot;:avail&quot;:{&quot;S&quot;:&quot;Available&quot;}, &quot;:back&quot;:{&quot;S&quot;:&quot;Backordered&quot;}, &quot;:disc&quot;:{&quot;S&quot;:&quot;Discontinued&quot;} }&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You could then use these values in an expression, such as this:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ProductStatus IN (:avail, :back, :disc)&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information on expression attribute values, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html&quot;&gt;Specifying Conditions&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expression_attribute_values</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">QueryInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;QueryInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;index_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">index_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;select&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">select</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;attributes_to_get&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">attributes_to_get</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;limit&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">limit</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consistent_read&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consistent_read</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;key_conditions&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">key_conditions</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;query_filter&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">query_filter</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;conditional_operator&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">conditional_operator</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;scan_index_forward&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">scan_index_forward</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;exclusive_start_key&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">exclusive_start_key</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;return_consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;projection_expression&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">projection_expression</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;filter_expression&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">filter_expression</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;key_condition_expression&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">key_condition_expression</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;expression_attribute_names&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expression_attribute_names</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;expression_attribute_values&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expression_attribute_values</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RestoreTableFromBackupInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the new table to which the backup must be restored.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">target_table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The Amazon Resource Name (ARN) associated with the backup.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">backup_arn</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The billing mode of the restored table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">billing_mode_override</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::BillingMode</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;List of global secondary indexes for the restored table. The indexes</span>
    <span class="doccomment">/// provided should match existing secondary indexes. You can choose to exclude</span>
    <span class="doccomment">/// some or all of the indexes at the time of restore.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_secondary_index_override</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::GlobalSecondaryIndex</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;List of local secondary indexes for the restored table. The indexes</span>
    <span class="doccomment">/// provided should match existing secondary indexes. You can choose to exclude</span>
    <span class="doccomment">/// some or all of the indexes at the time of restore.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">local_secondary_index_override</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::LocalSecondaryIndex</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Provisioned throughput settings for the restored table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">provisioned_throughput_override</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ProvisionedThroughput</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The new server-side encryption settings for the restored table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">sse_specification_override</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::SSESpecification</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">RestoreTableFromBackupInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;RestoreTableFromBackupInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;target_table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">target_table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;backup_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">backup_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;billing_mode_override&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">billing_mode_override</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;global_secondary_index_override&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_secondary_index_override</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;local_secondary_index_override&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">local_secondary_index_override</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;provisioned_throughput_override&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">provisioned_throughput_override</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;sse_specification_override&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">sse_specification_override</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RestoreTableToPointInTimeInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The DynamoDB table that will be restored. This value is an Amazon</span>
    <span class="doccomment">/// Resource Name (ARN).&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">source_table_arn</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Name of the source table that is being restored.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">source_table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The name of the new table to which it must be restored to.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">target_table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Restore the table to the latest possible time. &lt;code&gt;LatestRestorableDateTime&lt;/code&gt;</span>
    <span class="doccomment">/// is typically 5 minutes before the current time. &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">use_latest_restorable_time</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Time in the past to restore the table to.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">restore_date_time</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">smithy_types::Instant</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The billing mode of the restored table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">billing_mode_override</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::BillingMode</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;List of global secondary indexes for the restored table. The indexes</span>
    <span class="doccomment">/// provided should match existing secondary indexes. You can choose to exclude</span>
    <span class="doccomment">/// some or all of the indexes at the time of restore.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_secondary_index_override</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::GlobalSecondaryIndex</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;List of local secondary indexes for the restored table. The indexes</span>
    <span class="doccomment">/// provided should match existing secondary indexes. You can choose to exclude</span>
    <span class="doccomment">/// some or all of the indexes at the time of restore.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">local_secondary_index_override</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::LocalSecondaryIndex</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Provisioned throughput settings for the restored table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">provisioned_throughput_override</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ProvisionedThroughput</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The new server-side encryption settings for the restored table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">sse_specification_override</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::SSESpecification</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">RestoreTableToPointInTimeInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;RestoreTableToPointInTimeInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;source_table_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">source_table_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;source_table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">source_table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;target_table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">target_table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;use_latest_restorable_time&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">use_latest_restorable_time</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;restore_date_time&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">restore_date_time</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;billing_mode_override&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">billing_mode_override</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;global_secondary_index_override&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_secondary_index_override</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;local_secondary_index_override&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">local_secondary_index_override</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;provisioned_throughput_override&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">provisioned_throughput_override</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;sse_specification_override&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">sse_specification_override</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of a &lt;code&gt;Scan&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ScanInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table containing the requested items; or, if you provide</span>
    <span class="doccomment">/// &lt;code&gt;IndexName&lt;/code&gt;, the name of the table to which that index belongs.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The name of a secondary index to scan. This index can be any local secondary index or global secondary index.  Note that if you use the &lt;code&gt;IndexName&lt;/code&gt; parameter, you must also provide &lt;code&gt;TableName&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">index_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;ProjectionExpression&lt;/code&gt; instead.  For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html&quot;&gt;AttributesToGet&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">attributes_to_get</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The maximum number of items to evaluate (not necessarily the number of matching items).</span>
    <span class="doccomment">/// If DynamoDB processes the number of items up to the limit while processing the results,</span>
    <span class="doccomment">/// it stops the operation and returns the matching values up to that point, and a key in</span>
    <span class="doccomment">/// &lt;code&gt;LastEvaluatedKey&lt;/code&gt; to apply in a subsequent operation, so that you can</span>
    <span class="doccomment">/// pick up where you left off. Also, if the processed dataset size exceeds 1 MB before</span>
    <span class="doccomment">/// DynamoDB reaches this limit, it stops the operation and returns the matching values up</span>
    <span class="doccomment">/// to the limit, and a key in &lt;code&gt;LastEvaluatedKey&lt;/code&gt; to apply in a subsequent</span>
    <span class="doccomment">/// operation to continue the operation. For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html&quot;&gt;Working with Queries&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">limit</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The attributes to be returned in the</span>
    <span class="doccomment">/// result. You can retrieve all item attributes, specific item attributes, the count of</span>
    <span class="doccomment">/// matching items, or in the case of an index, some or all of the attributes projected into</span>
    <span class="doccomment">/// the index.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ALL_ATTRIBUTES&lt;/code&gt; - Returns all of the item attributes from the</span>
    <span class="doccomment">/// specified table or index. If you query a local secondary index, then for each</span>
    <span class="doccomment">/// matching item in the index, DynamoDB fetches the entire item from the parent</span>
    <span class="doccomment">/// table. If the index is configured to project all item attributes, then all of</span>
    <span class="doccomment">/// the data can be obtained from the local secondary index, and no fetching is</span>
    <span class="doccomment">/// required.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ALL_PROJECTED_ATTRIBUTES&lt;/code&gt; - Allowed only when querying an index.</span>
    <span class="doccomment">/// Retrieves all attributes that have been projected into the index. If the</span>
    <span class="doccomment">/// index is configured to project all attributes, this return value is</span>
    <span class="doccomment">/// equivalent to specifying &lt;code&gt;ALL_ATTRIBUTES&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;COUNT&lt;/code&gt; - Returns the number of matching items, rather than the</span>
    <span class="doccomment">/// matching items themselves.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;SPECIFIC_ATTRIBUTES&lt;/code&gt; - Returns only the attributes listed in</span>
    <span class="doccomment">/// &lt;code&gt;AttributesToGet&lt;/code&gt;. This return value is equivalent to</span>
    <span class="doccomment">/// specifying &lt;code&gt;AttributesToGet&lt;/code&gt; without specifying any value</span>
    <span class="doccomment">/// for &lt;code&gt;Select&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you query or scan a local secondary index and request only attributes that</span>
    <span class="doccomment">/// are projected into that index, the operation reads only the index and not the</span>
    <span class="doccomment">/// table. If any of the requested attributes are not projected into the local</span>
    <span class="doccomment">/// secondary index, DynamoDB fetches each of these attributes from the parent</span>
    <span class="doccomment">/// table. This extra fetching incurs additional throughput cost and latency.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you query or scan a global secondary index, you can only request</span>
    <span class="doccomment">/// attributes that are projected into the index. Global secondary index queries</span>
    <span class="doccomment">/// cannot fetch attributes from the parent table.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If neither &lt;code&gt;Select&lt;/code&gt; nor &lt;code&gt;AttributesToGet&lt;/code&gt;</span>
    <span class="doccomment">/// are specified, DynamoDB defaults to &lt;code&gt;ALL_ATTRIBUTES&lt;/code&gt; when accessing a</span>
    <span class="doccomment">/// table, and &lt;code&gt;ALL_PROJECTED_ATTRIBUTES&lt;/code&gt; when accessing an index. You cannot</span>
    <span class="doccomment">/// use both &lt;code&gt;Select&lt;/code&gt; and &lt;code&gt;AttributesToGet&lt;/code&gt;</span>
    <span class="doccomment">/// together in a single request, unless the value for &lt;code&gt;Select&lt;/code&gt; is</span>
    <span class="doccomment">/// &lt;code&gt;SPECIFIC_ATTRIBUTES&lt;/code&gt;. (This usage is equivalent to specifying</span>
    <span class="doccomment">/// &lt;code&gt;AttributesToGet&lt;/code&gt; without any value for</span>
    <span class="doccomment">/// &lt;code&gt;Select&lt;/code&gt;.)&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you use the &lt;code&gt;ProjectionExpression&lt;/code&gt; parameter, then</span>
    <span class="doccomment">/// the value for &lt;code&gt;Select&lt;/code&gt; can only be</span>
    <span class="doccomment">/// &lt;code&gt;SPECIFIC_ATTRIBUTES&lt;/code&gt;. Any other value for</span>
    <span class="doccomment">/// &lt;code&gt;Select&lt;/code&gt; will return an error.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="kw">pub</span> <span class="ident">select</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::Select</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;FilterExpression&lt;/code&gt; instead.   For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ScanFilter.html&quot;&gt;ScanFilter&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">scan_filter</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::Condition</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;FilterExpression&lt;/code&gt; instead.   For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html&quot;&gt;ConditionalOperator&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">conditional_operator</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConditionalOperator</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The primary key of the first item that this operation will evaluate. Use the value that was returned for &lt;code&gt;LastEvaluatedKey&lt;/code&gt; in the previous operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The data type for &lt;code&gt;ExclusiveStartKey&lt;/code&gt; must be String, Number or Binary. No set data types are allowed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;In a parallel scan, a</span>
    <span class="doccomment">/// &lt;code&gt;Scan&lt;/code&gt; request that includes &lt;code&gt;ExclusiveStartKey&lt;/code&gt; must specify the same segment</span>
    <span class="doccomment">/// whose previous &lt;code&gt;Scan&lt;/code&gt; returned the corresponding value of &lt;code&gt;LastEvaluatedKey&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">exclusive_start_key</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines the level of detail about provisioned throughput consumption that is returned in the response:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;INDEXES&lt;/code&gt; - The response includes the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation, together with &lt;code&gt;ConsumedCapacity&lt;/code&gt; for each table and secondary index that was accessed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Note that some operations, such as &lt;code&gt;GetItem&lt;/code&gt; and &lt;code&gt;BatchGetItem&lt;/code&gt;, do not access any indexes at all.  In these cases, specifying &lt;code&gt;INDEXES&lt;/code&gt; will only return &lt;code&gt;ConsumedCapacity&lt;/code&gt; information for table(s).&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;TOTAL&lt;/code&gt; - The response includes only the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt; - No &lt;code&gt;ConsumedCapacity&lt;/code&gt; details are included in the response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_consumed_capacity</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnConsumedCapacity</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;For a parallel &lt;code&gt;Scan&lt;/code&gt; request, &lt;code&gt;TotalSegments&lt;/code&gt; represents the total number of</span>
    <span class="doccomment">/// segments into which the &lt;code&gt;Scan&lt;/code&gt; operation will be divided. The value of</span>
    <span class="doccomment">/// &lt;code&gt;TotalSegments&lt;/code&gt; corresponds to the number of application workers that will perform the</span>
    <span class="doccomment">/// parallel scan. For example, if you want to use four application threads to scan a table or an index,</span>
    <span class="doccomment">/// specify a &lt;code&gt;TotalSegments&lt;/code&gt; value of 4.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The value for &lt;code&gt;TotalSegments&lt;/code&gt; must be greater than or equal to 1, and less than or equal</span>
    <span class="doccomment">/// to 1000000. If you specify a &lt;code&gt;TotalSegments&lt;/code&gt; value of 1, the &lt;code&gt;Scan&lt;/code&gt; operation will</span>
    <span class="doccomment">/// be sequential rather than parallel.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you specify &lt;code&gt;TotalSegments&lt;/code&gt;, you must also specify &lt;code&gt;Segment&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">total_segments</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;For a parallel &lt;code&gt;Scan&lt;/code&gt; request, &lt;code&gt;Segment&lt;/code&gt; identifies an individual segment to be</span>
    <span class="doccomment">/// scanned by an application worker.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Segment IDs are zero-based, so the first segment is always 0. For example, if you want to</span>
    <span class="doccomment">/// use four application threads to scan a table or an index, then the first thread specifies a &lt;code&gt;Segment&lt;/code&gt; value</span>
    <span class="doccomment">/// of 0, the second thread specifies 1, and so on.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The value of &lt;code&gt;LastEvaluatedKey&lt;/code&gt; returned from a parallel &lt;code&gt;Scan&lt;/code&gt; request must be</span>
    <span class="doccomment">/// used as &lt;code&gt;ExclusiveStartKey&lt;/code&gt; with the same segment ID in a subsequent &lt;code&gt;Scan&lt;/code&gt;</span>
    <span class="doccomment">/// operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The value for &lt;code&gt;Segment&lt;/code&gt; must be greater than or equal to 0, and less than the value</span>
    <span class="doccomment">/// provided for &lt;code&gt;TotalSegments&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you provide &lt;code&gt;Segment&lt;/code&gt;, you must also provide &lt;code&gt;TotalSegments&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">segment</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A string that identifies one or more attributes to retrieve from the specified table or index. These attributes can include scalars, sets, or elements of a JSON document. The attributes in the expression must be separated by commas.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If no attribute names are specified, then all attributes will be returned. If any of the requested attributes are not found, they will not appear in the result.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html&quot;&gt;Specifying Item Attributes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">projection_expression</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A string that contains conditions that DynamoDB applies after the &lt;code&gt;Scan&lt;/code&gt; operation, but</span>
    <span class="doccomment">/// before the data is returned to you. Items that do not satisfy the &lt;code&gt;FilterExpression&lt;/code&gt;</span>
    <span class="doccomment">/// criteria are not returned.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;A &lt;code&gt;FilterExpression&lt;/code&gt; is applied after the items have already been read; the process of</span>
    <span class="doccomment">/// filtering does not consume any additional read capacity units.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#FilteringResults&quot;&gt;Filter Expressions&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">filter_expression</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;One or more substitution tokens for attribute names in an expression. The following are some use cases for using &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To access an attribute whose name conflicts with a DynamoDB reserved word.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To create a placeholder for repeating occurrences of an attribute name in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To prevent special characters in an attribute name from being misinterpreted in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Use the &lt;b&gt;#&lt;/b&gt; character in an expression to dereference an attribute name. For example, consider the following attribute name:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Percentile&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The name of this attribute conflicts with a reserved word, so it cannot be used directly in an expression. (For the complete list of reserved words, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html&quot;&gt;Reserved Words&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;). To work around this, you could specify the following for &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;{&quot;#P&quot;:&quot;Percentile&quot;}&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You could then use this substitution in an expression, as in this example:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;#P = :val&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Tokens that begin with the &lt;b&gt;:&lt;/b&gt; character are &lt;i&gt;expression attribute values&lt;/i&gt;, which are placeholders for the actual value at runtime.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information on expression attribute names, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html&quot;&gt;Specifying Item Attributes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expression_attribute_names</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;One or more values that can be substituted in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Use the &lt;b&gt;:&lt;/b&gt; (colon) character in an expression to</span>
    <span class="doccomment">/// dereference an attribute value. For example, suppose that you wanted to check whether</span>
    <span class="doccomment">/// the value of the &lt;code&gt;ProductStatus&lt;/code&gt; attribute was one of the following: &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Available | Backordered | Discontinued&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You would first need to specify &lt;code&gt;ExpressionAttributeValues&lt;/code&gt; as follows:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;{ &quot;:avail&quot;:{&quot;S&quot;:&quot;Available&quot;}, &quot;:back&quot;:{&quot;S&quot;:&quot;Backordered&quot;}, &quot;:disc&quot;:{&quot;S&quot;:&quot;Discontinued&quot;} }&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You could then use these values in an expression, such as this:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ProductStatus IN (:avail, :back, :disc)&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information on expression attribute values, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html&quot;&gt;Condition Expressions&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expression_attribute_values</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A Boolean value that determines the read consistency model during the scan:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If &lt;code&gt;ConsistentRead&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then the data returned from</span>
    <span class="doccomment">/// &lt;code&gt;Scan&lt;/code&gt; might not contain the results from other recently</span>
    <span class="doccomment">/// completed write operations (&lt;code&gt;PutItem&lt;/code&gt;, &lt;code&gt;UpdateItem&lt;/code&gt;, or</span>
    <span class="doccomment">/// &lt;code&gt;DeleteItem&lt;/code&gt;).&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If &lt;code&gt;ConsistentRead&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then all of the write operations that completed before the &lt;code&gt;Scan&lt;/code&gt; began are guaranteed to be contained in the &lt;code&gt;Scan&lt;/code&gt; response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The default setting for &lt;code&gt;ConsistentRead&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The &lt;code&gt;ConsistentRead&lt;/code&gt; parameter is not supported on global secondary indexes. If you scan a global secondary index with &lt;code&gt;ConsistentRead&lt;/code&gt; set to true, you will receive a &lt;code&gt;ValidationException&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">consistent_read</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ScanInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ScanInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;index_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">index_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;attributes_to_get&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">attributes_to_get</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;limit&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">limit</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;select&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">select</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;scan_filter&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">scan_filter</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;conditional_operator&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">conditional_operator</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;exclusive_start_key&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">exclusive_start_key</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;return_consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;total_segments&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">total_segments</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;segment&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">segment</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;projection_expression&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">projection_expression</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;filter_expression&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">filter_expression</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;expression_attribute_names&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expression_attribute_names</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;expression_attribute_values&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expression_attribute_values</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consistent_read&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consistent_read</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">TagResourceInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;Identifies the Amazon DynamoDB resource to which tags should be added. This value is an Amazon Resource Name (ARN).&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">resource_arn</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The tags to be assigned to the Amazon DynamoDB resource.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">tags</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::Tag</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">TagResourceInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;TagResourceInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;resource_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">resource_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;tags&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">tags</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">TransactGetItemsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;An ordered array of up to 25 &lt;code&gt;TransactGetItem&lt;/code&gt; objects,</span>
    <span class="doccomment">/// each of which contains a &lt;code&gt;Get&lt;/code&gt; structure.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">transact_items</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::TransactGetItem</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A value of &lt;code&gt;TOTAL&lt;/code&gt; causes consumed capacity information</span>
    <span class="doccomment">/// to be returned, and a value of &lt;code&gt;NONE&lt;/code&gt; prevents that information</span>
    <span class="doccomment">/// from being returned. No other value is valid.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_consumed_capacity</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnConsumedCapacity</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">TransactGetItemsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;TransactGetItemsInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;transact_items&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">transact_items</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;return_consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">TransactWriteItemsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;An ordered array of up to 25 &lt;code&gt;TransactWriteItem&lt;/code&gt; objects, each of which</span>
    <span class="doccomment">/// contains a &lt;code&gt;ConditionCheck&lt;/code&gt;, &lt;code&gt;Put&lt;/code&gt;, &lt;code&gt;Update&lt;/code&gt;, or</span>
    <span class="doccomment">/// &lt;code&gt;Delete&lt;/code&gt; object. These can operate on items in different tables, but the</span>
    <span class="doccomment">/// tables must reside in the same AWS account and Region, and no two of them can operate on</span>
    <span class="doccomment">/// the same item. &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">transact_items</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::TransactWriteItem</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines the level of detail about provisioned throughput consumption that is returned in the response:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;INDEXES&lt;/code&gt; - The response includes the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation, together with &lt;code&gt;ConsumedCapacity&lt;/code&gt; for each table and secondary index that was accessed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Note that some operations, such as &lt;code&gt;GetItem&lt;/code&gt; and &lt;code&gt;BatchGetItem&lt;/code&gt;, do not access any indexes at all.  In these cases, specifying &lt;code&gt;INDEXES&lt;/code&gt; will only return &lt;code&gt;ConsumedCapacity&lt;/code&gt; information for table(s).&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;TOTAL&lt;/code&gt; - The response includes only the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt; - No &lt;code&gt;ConsumedCapacity&lt;/code&gt; details are included in the response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_consumed_capacity</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnConsumedCapacity</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines whether item collection metrics are returned. If set to</span>
    <span class="doccomment">/// &lt;code&gt;SIZE&lt;/code&gt;, the response includes statistics about item collections (if any), that</span>
    <span class="doccomment">/// were modified during the operation and are returned in the response.</span>
    <span class="doccomment">/// If set to &lt;code&gt;NONE&lt;/code&gt; (the default), no statistics are returned.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_item_collection_metrics</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnItemCollectionMetrics</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Providing a &lt;code&gt;ClientRequestToken&lt;/code&gt; makes the call to &lt;code&gt;TransactWriteItems&lt;/code&gt;</span>
    <span class="doccomment">/// idempotent, meaning that multiple identical calls have the same effect as one single call.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Although multiple identical calls using the same client request token produce the same</span>
    <span class="doccomment">/// result on the server (no side effects), the responses to the calls might not be the</span>
    <span class="doccomment">/// same. If the &lt;code&gt;ReturnConsumedCapacity&gt;&lt;/code&gt; parameter is set, then the initial</span>
    <span class="doccomment">/// &lt;code&gt;TransactWriteItems&lt;/code&gt; call returns the amount of write capacity units</span>
    <span class="doccomment">/// consumed in making the changes. Subsequent &lt;code&gt;TransactWriteItems&lt;/code&gt; calls with</span>
    <span class="doccomment">/// the same client token return the number of read capacity units consumed in reading the</span>
    <span class="doccomment">/// item.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;A client request token is valid for 10 minutes after the first request that uses it is</span>
    <span class="doccomment">/// completed. After 10 minutes, any request with the same client token is treated as a new</span>
    <span class="doccomment">/// request. Do not resubmit the same request with the same client token for more than 10</span>
    <span class="doccomment">/// minutes, or the result might not be idempotent.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you submit a request with the same client token but a change in other parameters</span>
    <span class="doccomment">/// within the 10-minute idempotency window, DynamoDB returns an</span>
    <span class="doccomment">/// &lt;code&gt;IdempotentParameterMismatch&lt;/code&gt; exception.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">client_request_token</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">TransactWriteItemsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;TransactWriteItemsInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;transact_items&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">transact_items</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;return_consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;return_item_collection_metrics&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_item_collection_metrics</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;client_request_token&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">client_request_token</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UntagResourceInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The DynamoDB resource that the tags will be removed from. This value is an Amazon</span>
    <span class="doccomment">/// Resource Name (ARN).&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">resource_arn</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A list of tag keys. Existing tags of the resource whose keys are members of this list</span>
    <span class="doccomment">/// will be removed from the DynamoDB resource.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">tag_keys</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UntagResourceInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UntagResourceInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;resource_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">resource_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;tag_keys&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">tag_keys</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateContinuousBackupsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Represents the settings used to enable point in time recovery.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">point_in_time_recovery_specification</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::PointInTimeRecoverySpecification</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateContinuousBackupsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateContinuousBackupsInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;point_in_time_recovery_specification&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">point_in_time_recovery_specification</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateContributorInsightsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The global secondary index name, if applicable.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">index_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Represents the contributor insights action.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">contributor_insights_action</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ContributorInsightsAction</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateContributorInsightsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateContributorInsightsInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;index_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">index_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;contributor_insights_action&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">contributor_insights_action</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateGlobalTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The global table name.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A list of Regions that should be added or removed from the global table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">replica_updates</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReplicaUpdate</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateGlobalTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateGlobalTableInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;global_table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;replica_updates&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">replica_updates</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateGlobalTableSettingsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the global table&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The billing mode of the global table. If &lt;code&gt;GlobalTableBillingMode&lt;/code&gt; is not specified, the global table defaults to &lt;code&gt;PROVISIONED&lt;/code&gt; capacity billing mode.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;PROVISIONED&lt;/code&gt; - We recommend using &lt;code&gt;PROVISIONED&lt;/code&gt; for predictable workloads. &lt;code&gt;PROVISIONED&lt;/code&gt; sets the billing mode to &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual&quot;&gt;Provisioned Mode&lt;/a&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; - We recommend using &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; for unpredictable workloads. &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; sets the billing mode to &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand&quot;&gt;On-Demand Mode&lt;/a&gt;.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_table_billing_mode</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::BillingMode</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The maximum number of writes consumed per second before DynamoDB returns a &lt;code&gt;ThrottlingException.&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_table_provisioned_write_capacity_units</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Auto scaling settings for managing provisioned write capacity for the global</span>
    <span class="doccomment">/// table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_table_provisioned_write_capacity_auto_scaling_settings_update</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::AutoScalingSettingsUpdate</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Represents the settings of a global secondary index for a global table that will be modified.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_table_global_secondary_index_settings_update</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::GlobalTableGlobalSecondaryIndexSettingsUpdate</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Represents the settings for a global table in a Region that will be modified.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">replica_settings_update</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReplicaSettingsUpdate</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateGlobalTableSettingsInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateGlobalTableSettingsInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;global_table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;global_table_billing_mode&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_billing_mode</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;global_table_provisioned_write_capacity_units&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_provisioned_write_capacity_units</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;global_table_provisioned_write_capacity_auto_scaling_settings_update&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_provisioned_write_capacity_auto_scaling_settings_update</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;global_table_global_secondary_index_settings_update&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_global_secondary_index_settings_update</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;replica_settings_update&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">replica_settings_update</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of an &lt;code&gt;UpdateItem&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateItemInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table containing the item to update.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The primary key of the item to be updated. Each element consists of an attribute name and a value for that attribute.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For the primary key, you must provide all of the attributes. For example, with a simple primary key, you only need to provide a value for the partition key. For a composite primary key, you must provide values for both the partition key and the sort key.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">key</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;UpdateExpression&lt;/code&gt; instead.   For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributeUpdates.html&quot;&gt;AttributeUpdates&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">attribute_updates</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValueUpdate</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;ConditionExpression&lt;/code&gt; instead.   For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html&quot;&gt;Expected&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expected</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::ExpectedAttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;This is a legacy parameter.  Use &lt;code&gt;ConditionExpression&lt;/code&gt; instead.   For more information, see</span>
    <span class="doccomment">/// &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html&quot;&gt;ConditionalOperator&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">conditional_operator</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConditionalOperator</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Use &lt;code&gt;ReturnValues&lt;/code&gt; if you want to get the item attributes as they appear</span>
    <span class="doccomment">/// before or after they are updated. For &lt;code&gt;UpdateItem&lt;/code&gt;, the valid values</span>
    <span class="doccomment">/// are:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt; - If &lt;code&gt;ReturnValues&lt;/code&gt; is not specified, or if its value is</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt;, then nothing is returned. (This setting is the default for</span>
    <span class="doccomment">/// &lt;code&gt;ReturnValues&lt;/code&gt;.)&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ALL_OLD&lt;/code&gt; - Returns all of the attributes of the item, as they appeared before the UpdateItem operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;UPDATED_OLD&lt;/code&gt; - Returns only the updated attributes, as they appeared before the UpdateItem operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ALL_NEW&lt;/code&gt; - Returns all of the attributes of the item, as they appear after the UpdateItem operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;UPDATED_NEW&lt;/code&gt; - Returns only the updated attributes, as they appear after the UpdateItem operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;There is no additional cost associated with requesting a return value aside from the</span>
    <span class="doccomment">/// small network and processing overhead of receiving a larger response. No read capacity</span>
    <span class="doccomment">/// units are consumed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The values returned are strongly consistent.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_values</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnValue</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines the level of detail about provisioned throughput consumption that is returned in the response:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;INDEXES&lt;/code&gt; - The response includes the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation, together with &lt;code&gt;ConsumedCapacity&lt;/code&gt; for each table and secondary index that was accessed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Note that some operations, such as &lt;code&gt;GetItem&lt;/code&gt; and &lt;code&gt;BatchGetItem&lt;/code&gt;, do not access any indexes at all.  In these cases, specifying &lt;code&gt;INDEXES&lt;/code&gt; will only return &lt;code&gt;ConsumedCapacity&lt;/code&gt; information for table(s).&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;TOTAL&lt;/code&gt; - The response includes only the aggregate &lt;code&gt;ConsumedCapacity&lt;/code&gt; for the operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;NONE&lt;/code&gt; - No &lt;code&gt;ConsumedCapacity&lt;/code&gt; details are included in the response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_consumed_capacity</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnConsumedCapacity</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Determines whether item collection metrics are returned.  If set to &lt;code&gt;SIZE&lt;/code&gt;, the response includes statistics about item collections, if any, that were modified during</span>
    <span class="doccomment">/// the operation are returned in the response. If set to &lt;code&gt;NONE&lt;/code&gt; (the default), no statistics are returned.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">return_item_collection_metrics</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReturnItemCollectionMetrics</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;An expression that defines one or more attributes to be updated, the action to be</span>
    <span class="doccomment">/// performed on them, and new values for them.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The following action values are available for &lt;code&gt;UpdateExpression&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;SET&lt;/code&gt; - Adds one or more attributes and values to an item. If any of</span>
    <span class="doccomment">/// these attributes already exist, they are replaced by the new values. You can</span>
    <span class="doccomment">/// also use &lt;code&gt;SET&lt;/code&gt; to add or subtract from an attribute that is of type</span>
    <span class="doccomment">/// Number. For example: &lt;code&gt;SET myNum = myNum + :val&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;SET&lt;/code&gt; supports the following functions:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;if_not_exists (path, operand)&lt;/code&gt; - if the item does not contain an attribute at the specified path, then &lt;code&gt;if_not_exists&lt;/code&gt; evaluates to operand; otherwise, it evaluates to path. You can use this function to avoid overwriting an attribute that may already be present in the item.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;list_append (operand, operand)&lt;/code&gt; - evaluates to a list with a new element added to it. You can append the new element to the start or the end of the list by reversing the order of the operands.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;These function names are case-sensitive.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;REMOVE&lt;/code&gt; - Removes one or more attributes from an item.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ADD&lt;/code&gt; - Adds the specified value to the item, if the attribute does not already exist. If the attribute does exist, then the behavior of</span>
    <span class="doccomment">/// &lt;code&gt;ADD&lt;/code&gt; depends on the data type of the attribute:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If the existing attribute is a number, and if &lt;code&gt;Value&lt;/code&gt; is also a number, then</span>
    <span class="doccomment">/// &lt;code&gt;Value&lt;/code&gt; is mathematically added to the existing attribute. If &lt;code&gt;Value&lt;/code&gt; is a</span>
    <span class="doccomment">/// negative number, then it is subtracted from the existing attribute.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you use &lt;code&gt;ADD&lt;/code&gt; to increment or decrement a number value for an item</span>
    <span class="doccomment">/// that doesn&#39;t exist before the update, DynamoDB uses &lt;code&gt;0&lt;/code&gt; as the initial</span>
    <span class="doccomment">/// value.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Similarly, if you use &lt;code&gt;ADD&lt;/code&gt; for an existing item to increment</span>
    <span class="doccomment">/// or decrement an attribute value that doesn&#39;t exist before the</span>
    <span class="doccomment">/// update, DynamoDB uses &lt;code&gt;0&lt;/code&gt; as the initial value. For</span>
    <span class="doccomment">/// example, suppose that the item you want to update doesn&#39;t have an</span>
    <span class="doccomment">/// attribute named &lt;code&gt;itemcount&lt;/code&gt;, but you decide to</span>
    <span class="doccomment">/// &lt;code&gt;ADD&lt;/code&gt; the number &lt;code&gt;3&lt;/code&gt; to this attribute</span>
    <span class="doccomment">/// anyway. DynamoDB will create the &lt;code&gt;itemcount&lt;/code&gt; attribute,</span>
    <span class="doccomment">/// set its initial value to &lt;code&gt;0&lt;/code&gt;, and finally add</span>
    <span class="doccomment">/// &lt;code&gt;3&lt;/code&gt; to it. The result will be a new</span>
    <span class="doccomment">/// &lt;code&gt;itemcount&lt;/code&gt; attribute in the item, with a value of</span>
    <span class="doccomment">/// &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If the existing data type is a set and if &lt;code&gt;Value&lt;/code&gt; is also a set, then</span>
    <span class="doccomment">/// &lt;code&gt;Value&lt;/code&gt; is added to the existing set. For example, if the attribute value is the set</span>
    <span class="doccomment">/// &lt;code&gt;[1,2]&lt;/code&gt;, and the &lt;code&gt;ADD&lt;/code&gt; action specified &lt;code&gt;[3]&lt;/code&gt;, then</span>
    <span class="doccomment">/// the final attribute value is &lt;code&gt;[1,2,3]&lt;/code&gt;. An error occurs if an &lt;code&gt;ADD&lt;/code&gt;</span>
    <span class="doccomment">/// action is specified for a set attribute and the attribute type specified does not</span>
    <span class="doccomment">/// match the existing set type. &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Both sets must have the same primitive data type. For example, if the existing data</span>
    <span class="doccomment">/// type is a set of strings, the &lt;code&gt;Value&lt;/code&gt; must also be a set of strings.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;important&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The &lt;code&gt;ADD&lt;/code&gt; action only supports Number and set data types. In addition,</span>
    <span class="doccomment">/// &lt;code&gt;ADD&lt;/code&gt; can only be used on top-level attributes, not nested attributes.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/important&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;DELETE&lt;/code&gt; - Deletes an element from a set.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If a set of values is specified, then those values are subtracted from the old</span>
    <span class="doccomment">/// set. For example, if the attribute value was the set &lt;code&gt;[a,b,c]&lt;/code&gt; and the</span>
    <span class="doccomment">/// &lt;code&gt;DELETE&lt;/code&gt; action specifies &lt;code&gt;[a,c]&lt;/code&gt;, then the final attribute value</span>
    <span class="doccomment">/// is &lt;code&gt;[b]&lt;/code&gt;. Specifying an empty set is an error.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;important&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The &lt;code&gt;DELETE&lt;/code&gt; action only supports set data types. In addition,</span>
    <span class="doccomment">/// &lt;code&gt;DELETE&lt;/code&gt; can only be used on top-level attributes, not nested attributes.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/important&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You can have many actions in a single expression, such as the following: &lt;code&gt;SET a=:value1,</span>
    <span class="doccomment">/// b=:value2 DELETE :value3, :value4, :value5&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information on update expressions, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Modifying.html&quot;&gt;Modifying Items and Attributes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">update_expression</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A condition that must be satisfied in order for a conditional update to succeed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;An expression can contain any of the following:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Functions: &lt;code&gt;attribute_exists | attribute_not_exists | attribute_type | contains | begins_with | size&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;These function names are case-sensitive.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Comparison operators: &lt;code&gt;= | &lt;&gt; |</span>
    <span class="doccomment">/// &lt; | &gt; | &lt;= | &gt;= |</span>
    <span class="doccomment">/// BETWEEN | IN &lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt; Logical operators: &lt;code&gt;AND | OR | NOT&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information about condition expressions, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html&quot;&gt;Specifying Conditions&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">condition_expression</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;One or more substitution tokens for attribute names in an expression. The following are some use cases for using &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To access an attribute whose name conflicts with a DynamoDB reserved word.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To create a placeholder for repeating occurrences of an attribute name in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;To prevent special characters in an attribute name from being misinterpreted in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Use the &lt;b&gt;#&lt;/b&gt; character in an expression to dereference an attribute name. For example, consider the following attribute name:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Percentile&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The name of this attribute conflicts with a reserved word, so it cannot be used directly</span>
    <span class="doccomment">/// in an expression. (For the complete list of reserved words, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html&quot;&gt;Reserved Words&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.) To work around this, you could specify the following for</span>
    <span class="doccomment">/// &lt;code&gt;ExpressionAttributeNames&lt;/code&gt;:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;{&quot;#P&quot;:&quot;Percentile&quot;}&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You could then use this substitution in an expression, as in this example:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;#P = :val&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Tokens that begin with the &lt;b&gt;:&lt;/b&gt; character are &lt;i&gt;expression attribute values&lt;/i&gt;, which are placeholders for the actual value at runtime.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information about expression attribute names, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html&quot;&gt;Specifying Item Attributes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expression_attribute_names</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;One or more values that can be substituted in an expression.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Use the &lt;b&gt;:&lt;/b&gt; (colon) character in an expression to</span>
    <span class="doccomment">/// dereference an attribute value. For example, suppose that you wanted to check whether</span>
    <span class="doccomment">/// the value of the &lt;code&gt;ProductStatus&lt;/code&gt; attribute was one of the following: &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Available | Backordered | Discontinued&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You would first need to specify &lt;code&gt;ExpressionAttributeValues&lt;/code&gt; as follows:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;{ &quot;:avail&quot;:{&quot;S&quot;:&quot;Available&quot;}, &quot;:back&quot;:{&quot;S&quot;:&quot;Backordered&quot;}, &quot;:disc&quot;:{&quot;S&quot;:&quot;Discontinued&quot;} }&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You could then use these values in an expression, such as this:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ProductStatus IN (:avail, :back, :disc)&lt;/code&gt;</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information on expression attribute values, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html&quot;&gt;Condition Expressions&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">expression_attribute_values</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateItemInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateItemInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;key&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">key</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;attribute_updates&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">attribute_updates</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;expected&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expected</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;conditional_operator&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">conditional_operator</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;return_values&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_values</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;return_consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;return_item_collection_metrics&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">return_item_collection_metrics</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;update_expression&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">update_expression</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;condition_expression&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">condition_expression</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;expression_attribute_names&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expression_attribute_names</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;expression_attribute_values&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">expression_attribute_values</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of an &lt;code&gt;UpdateTable&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;An array of attributes that describe the key schema for the table and indexes. If you are adding a new global secondary index to the table, &lt;code&gt;AttributeDefinitions&lt;/code&gt; must include the key element(s) of the new index.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">attribute_definitions</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::AttributeDefinition</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The name of the table to be updated.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Controls how you are charged for read and write throughput and how you manage capacity.</span>
    <span class="doccomment">/// When switching from pay-per-request to provisioned capacity, initial provisioned capacity values must be set. The initial</span>
    <span class="doccomment">/// provisioned capacity values are estimated based on the consumed read and write capacity of your table and global secondary indexes</span>
    <span class="doccomment">/// over the past 30 minutes.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;PROVISIONED&lt;/code&gt; - We recommend using &lt;code&gt;PROVISIONED&lt;/code&gt; for predictable workloads. &lt;code&gt;PROVISIONED&lt;/code&gt; sets the billing mode to &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual&quot;&gt;Provisioned Mode&lt;/a&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; - We recommend using &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; for unpredictable workloads. &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; sets the billing mode to &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand&quot;&gt;On-Demand Mode&lt;/a&gt;.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="kw">pub</span> <span class="ident">billing_mode</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::BillingMode</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The new provisioned throughput settings for the specified table or index.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">provisioned_throughput</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ProvisionedThroughput</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;An array of one or more global secondary indexes for the table. For each index in the array, you can request one action:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Create&lt;/code&gt; - add a new global secondary index to the table.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Update&lt;/code&gt; - modify the provisioned throughput settings of an existing global secondary index.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Delete&lt;/code&gt; - remove a global secondary index from the table.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You can create or delete only one global secondary index per &lt;code&gt;UpdateTable&lt;/code&gt; operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.OnlineOps.html&quot;&gt;Managing Global Secondary</span>
    <span class="doccomment">/// Indexes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;. &lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_secondary_index_updates</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::GlobalSecondaryIndexUpdate</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Represents the DynamoDB Streams configuration for the table.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;You receive a &lt;code&gt;ResourceInUseException&lt;/code&gt; if you try to enable a stream on a</span>
    <span class="doccomment">/// table that already has a stream, or if you try to disable a stream on a table that</span>
    <span class="doccomment">/// doesn&#39;t have a stream.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="kw">pub</span> <span class="ident">stream_specification</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::StreamSpecification</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The new server-side encryption settings for the specified table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">sse_specification</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::SSESpecification</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A list of replica update actions (create, delete, or update) for the table.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;note&gt;</span>
    <span class="doccomment">/// &lt;p&gt;This property only applies to &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html&quot;&gt;Version 2019.11.21&lt;/a&gt; of global tables.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/note&gt;</span>
    <span class="kw">pub</span> <span class="ident">replica_updates</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReplicationGroupUpdate</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateTableInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateTableInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;attribute_definitions&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">attribute_definitions</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;billing_mode&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">billing_mode</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;provisioned_throughput&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">provisioned_throughput</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;global_secondary_index_updates&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_secondary_index_updates</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;stream_specification&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">stream_specification</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;sse_specification&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">sse_specification</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;replica_updates&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">replica_updates</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateTableReplicaAutoScalingInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;Represents the auto scaling settings of the global secondary indexes of the replica</span>
    <span class="doccomment">/// to be updated.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">global_secondary_index_updates</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::GlobalSecondaryIndexAutoScalingUpdate</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The name of the global table to be updated.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Represents the auto scaling settings to be modified for a global table or global</span>
    <span class="doccomment">/// secondary index.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">provisioned_write_capacity_auto_scaling_update</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::AutoScalingSettingsUpdate</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Represents the auto scaling settings of replicas of the table that will be</span>
    <span class="doccomment">/// modified.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">replica_updates</span>:
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReplicaAutoScalingUpdate</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateTableReplicaAutoScalingInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateTableReplicaAutoScalingInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;global_secondary_index_updates&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_secondary_index_updates</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;provisioned_write_capacity_auto_scaling_update&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">provisioned_write_capacity_auto_scaling_update</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;replica_updates&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">replica_updates</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the input of an &lt;code&gt;UpdateTimeToLive&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateTimeToLiveInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table to be configured.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Represents the settings used to enable or disable Time to Live for the specified table.&lt;/p&gt;</span>
    <span class="kw">pub</span> <span class="ident">time_to_live_specification</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::TimeToLiveSpecification</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateTimeToLiveInputBody</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateTimeToLiveInputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;time_to_live_specification&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">time_to_live_specification</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">BatchExecuteStatementOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// The response to each PartiQL statement in the batch.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Responses&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">responses</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::BatchStatementResponse</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">BatchExecuteStatementOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;BatchExecuteStatementOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;responses&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">responses</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of a &lt;code&gt;BatchGetItem&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">BatchGetItemOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;A map of table name to a list of items. Each object in &lt;code&gt;Responses&lt;/code&gt; consists of a table</span>
    <span class="doccomment">/// name, along with a map of attribute data consisting of the data type and attribute value.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Responses&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">responses</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span>
            <span class="ident">std::string::String</span>,
            <span class="ident">std::vec::Vec</span><span class="op">&lt;</span>
                <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
            <span class="op">&gt;</span>,
        <span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A map of tables and their respective keys that were not processed with the current response.</span>
    <span class="doccomment">/// The &lt;code&gt;UnprocessedKeys&lt;/code&gt; value is in the same form as &lt;code&gt;RequestItems&lt;/code&gt;, so the value can</span>
    <span class="doccomment">/// be provided directly to a subsequent &lt;code&gt;BatchGetItem&lt;/code&gt; operation. For more information, see</span>
    <span class="doccomment">/// &lt;code&gt;RequestItems&lt;/code&gt; in the Request Parameters section.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Each element consists of:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Keys&lt;/code&gt; - An array of primary key attribute values that define specific items in the</span>
    <span class="doccomment">/// table.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ProjectionExpression&lt;/code&gt; - One or more attributes to be</span>
    <span class="doccomment">/// retrieved from the table or index. By default, all attributes are returned. If a</span>
    <span class="doccomment">/// requested attribute is not found, it does not appear in the result.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ConsistentRead&lt;/code&gt; - The consistency of a read operation. If set to &lt;code&gt;true&lt;/code&gt;,</span>
    <span class="doccomment">/// then a strongly consistent read is used; otherwise, an eventually consistent read is</span>
    <span class="doccomment">/// used.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If there are no unprocessed keys remaining, the response contains an empty</span>
    <span class="doccomment">/// &lt;code&gt;UnprocessedKeys&lt;/code&gt; map.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;UnprocessedKeys&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">unprocessed_keys</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::KeysAndAttributes</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The read capacity units consumed by the entire &lt;code&gt;BatchGetItem&lt;/code&gt; operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Each element consists of:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;TableName&lt;/code&gt; - The table that consumed the provisioned throughput.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;CapacityUnits&lt;/code&gt; - The total number of capacity units consumed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ConsumedCapacity&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">consumed_capacity</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConsumedCapacity</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">BatchGetItemOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;BatchGetItemOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;responses&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">responses</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;unprocessed_keys&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">unprocessed_keys</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of a &lt;code&gt;BatchWriteItem&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">BatchWriteItemOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;A map of tables and requests against those tables that were not processed. The</span>
    <span class="doccomment">/// &lt;code&gt;UnprocessedItems&lt;/code&gt; value is in the same form as &lt;code&gt;RequestItems&lt;/code&gt;, so you can provide</span>
    <span class="doccomment">/// this value directly to a subsequent &lt;code&gt;BatchGetItem&lt;/code&gt; operation. For more information, see</span>
    <span class="doccomment">/// &lt;code&gt;RequestItems&lt;/code&gt; in the Request Parameters section.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Each &lt;code&gt;UnprocessedItems&lt;/code&gt; entry consists of a table name and, for that table, a list of</span>
    <span class="doccomment">/// operations to perform (&lt;code&gt;DeleteRequest&lt;/code&gt; or &lt;code&gt;PutRequest&lt;/code&gt;).&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;DeleteRequest&lt;/code&gt; - Perform a &lt;code&gt;DeleteItem&lt;/code&gt; operation on the specified item. The</span>
    <span class="doccomment">/// item to be deleted is identified by a &lt;code&gt;Key&lt;/code&gt; subelement:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Key&lt;/code&gt; - A map of primary key attribute values that uniquely identify the item.</span>
    <span class="doccomment">/// Each entry in this map consists of an attribute name and an attribute value.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;PutRequest&lt;/code&gt; - Perform a &lt;code&gt;PutItem&lt;/code&gt; operation on the specified item. The item to</span>
    <span class="doccomment">/// be put is identified by an &lt;code&gt;Item&lt;/code&gt; subelement:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;Item&lt;/code&gt; - A map of attributes and their values. Each entry in this map consists</span>
    <span class="doccomment">/// of an attribute name and an attribute value. Attribute values must not be null; string</span>
    <span class="doccomment">/// and binary type attributes must have lengths greater than zero; and set type</span>
    <span class="doccomment">/// attributes must not be empty. Requests that contain empty values will be rejected with</span>
    <span class="doccomment">/// a &lt;code&gt;ValidationException&lt;/code&gt; exception.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you specify any attributes that are part of an index key, then the data types for those attributes must match those of the schema in the table&#39;s attribute definition.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If there are no unprocessed items remaining, the response contains an empty</span>
    <span class="doccomment">/// &lt;code&gt;UnprocessedItems&lt;/code&gt; map.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;UnprocessedItems&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">unprocessed_items</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::WriteRequest</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A list of tables that were processed by &lt;code&gt;BatchWriteItem&lt;/code&gt; and, for each table,</span>
    <span class="doccomment">/// information about any item collections that were affected by individual &lt;code&gt;DeleteItem&lt;/code&gt; or</span>
    <span class="doccomment">/// &lt;code&gt;PutItem&lt;/code&gt; operations.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Each entry consists of the following subelements:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ItemCollectionKey&lt;/code&gt; - The partition key value of the item collection. This is the same as</span>
    <span class="doccomment">/// the partition key value of the item.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;SizeEstimateRangeGB&lt;/code&gt; - An estimate of item collection size, expressed in GB. This is</span>
    <span class="doccomment">/// a two-element array containing a lower bound and an upper bound for the estimate. The</span>
    <span class="doccomment">/// estimate includes the size of all the items in the table, plus the size of all attributes</span>
    <span class="doccomment">/// projected into all of the local secondary indexes on the table. Use this estimate to measure whether a</span>
    <span class="doccomment">/// local secondary index is approaching its size limit.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The estimate is subject to change over time; therefore, do not rely on the precision or accuracy of the estimate.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ItemCollectionMetrics&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">item_collection_metrics</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span>
            <span class="ident">std::string::String</span>,
            <span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ItemCollectionMetrics</span><span class="op">&gt;</span>,
        <span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The capacity units consumed by the entire &lt;code&gt;BatchWriteItem&lt;/code&gt; operation.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Each element consists of:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;TableName&lt;/code&gt; - The table that consumed the provisioned throughput.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;CapacityUnits&lt;/code&gt; - The total number of capacity units consumed.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ConsumedCapacity&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">consumed_capacity</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConsumedCapacity</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">BatchWriteItemOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;BatchWriteItemOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;unprocessed_items&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">unprocessed_items</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;item_collection_metrics&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">item_collection_metrics</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">CreateBackupOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Contains the details of the backup created for the table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;BackupDetails&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">backup_details</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::BackupDetails</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">CreateBackupOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;CreateBackupOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;backup_details&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">backup_details</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">CreateGlobalTableOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Contains the details of the global table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;GlobalTableDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">global_table_description</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::GlobalTableDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">CreateGlobalTableOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;CreateGlobalTableOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;global_table_description&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_description</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of a &lt;code&gt;CreateTable&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">CreateTableOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Represents the properties of the table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_description</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::TableDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">CreateTableOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;CreateTableOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_description&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_description</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DeleteBackupOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Contains the description of the backup created for the table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;BackupDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">backup_description</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::BackupDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DeleteBackupOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DeleteBackupOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;backup_description&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">backup_description</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of a &lt;code&gt;DeleteItem&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DeleteItemOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;A map of attribute names to &lt;code&gt;AttributeValue&lt;/code&gt; objects, representing the item as it</span>
    <span class="doccomment">/// appeared before the &lt;code&gt;DeleteItem&lt;/code&gt; operation. This map appears in the response only if</span>
    <span class="doccomment">/// &lt;code&gt;ReturnValues&lt;/code&gt; was specified as &lt;code&gt;ALL_OLD&lt;/code&gt; in the request.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Attributes&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">attributes</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The capacity units consumed by the &lt;code&gt;DeleteItem&lt;/code&gt; operation. The data</span>
    <span class="doccomment">/// returned includes the total provisioned throughput consumed, along with statistics for</span>
    <span class="doccomment">/// the table and any indexes involved in the operation. &lt;code&gt;ConsumedCapacity&lt;/code&gt; is</span>
    <span class="doccomment">/// only returned if the &lt;code&gt;ReturnConsumedCapacity&lt;/code&gt; parameter was specified. For</span>
    <span class="doccomment">/// more information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html&quot;&gt;Provisioned Mode&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ConsumedCapacity&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">consumed_capacity</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConsumedCapacity</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Information about item collections, if any, that were affected by the</span>
    <span class="doccomment">/// &lt;code&gt;DeleteItem&lt;/code&gt; operation.</span>
    <span class="doccomment">/// &lt;code&gt;ItemCollectionMetrics&lt;/code&gt; is only returned if the</span>
    <span class="doccomment">/// &lt;code&gt;ReturnItemCollectionMetrics&lt;/code&gt; parameter was specified. If the</span>
    <span class="doccomment">/// table does not have any local secondary indexes, this information is not returned in the</span>
    <span class="doccomment">/// response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Each &lt;code&gt;ItemCollectionMetrics&lt;/code&gt;</span>
    <span class="doccomment">/// element consists of:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ItemCollectionKey&lt;/code&gt; - The partition key value of the item</span>
    <span class="doccomment">/// collection. This is the same as the partition key value of the item itself.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;SizeEstimateRangeGB&lt;/code&gt; - An estimate of item collection size,</span>
    <span class="doccomment">/// in gigabytes. This value is a two-element array</span>
    <span class="doccomment">/// containing a lower bound and an upper bound for the</span>
    <span class="doccomment">/// estimate. The estimate includes the size of all the</span>
    <span class="doccomment">/// items in the table, plus the size of all attributes</span>
    <span class="doccomment">/// projected into all of the local secondary indexes on that</span>
    <span class="doccomment">/// table. Use this estimate to measure whether a local secondary index is approaching its size limit.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The estimate is subject to change over time; therefore, do not rely on the precision or accuracy of the estimate.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ItemCollectionMetrics&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">item_collection_metrics</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ItemCollectionMetrics</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DeleteItemOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DeleteItemOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;attributes&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">attributes</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;item_collection_metrics&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">item_collection_metrics</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of a &lt;code&gt;DeleteTable&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DeleteTableOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Represents the properties of a table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_description</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::TableDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DeleteTableOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DeleteTableOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_description&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_description</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeBackupOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Contains the description of the backup created for the table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;BackupDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">backup_description</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::BackupDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeBackupOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeBackupOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;backup_description&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">backup_description</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeContinuousBackupsOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Represents the continuous backups and point in time recovery settings on the table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ContinuousBackupsDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">continuous_backups_description</span>:
        <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ContinuousBackupsDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeContinuousBackupsOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeContinuousBackupsOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;continuous_backups_description&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">continuous_backups_description</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeContributorInsightsOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table being described.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableName&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The name of the global secondary index being described.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;IndexName&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">index_name</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;List of names of the associated Alpine rules.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ContributorInsightsRuleList&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">contributor_insights_rule_list</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Current Status contributor insights.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ContributorInsightsStatus&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">contributor_insights_status</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ContributorInsightsStatus</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Timestamp of the last time the status was changed.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;LastUpdateDateTime&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(
        <span class="ident">deserialize_with</span> <span class="op">=</span> <span class="string">&quot;crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser&quot;</span>
    )]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">last_update_date_time</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">smithy_types::Instant</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Returns information about the last failure that encountered.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The most common exceptions for a FAILED status are:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;LimitExceededException -   Per-account Amazon CloudWatch Contributor Insights rule limit reached. Please disable Contributor Insights for</span>
    <span class="doccomment">/// other tables/indexes OR disable Contributor Insights rules before retrying.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;AccessDeniedException - Amazon CloudWatch Contributor Insights rules cannot be modified due to insufficient permissions.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;AccessDeniedException - Failed to create service-linked role for Contributor Insights due to insufficient permissions.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;InternalServerError - Failed to create Amazon CloudWatch Contributor Insights rules. Please retry request.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;FailureException&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">failure_exception</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::FailureException</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeContributorInsightsOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeContributorInsightsOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;index_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">index_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;contributor_insights_rule_list&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">contributor_insights_rule_list</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;contributor_insights_status&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">contributor_insights_status</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;last_update_date_time&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">last_update_date_time</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;failure_exception&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">failure_exception</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeEndpointsOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;List of endpoints.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Endpoints&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">endpoints</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::Endpoint</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeEndpointsOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeEndpointsOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;endpoints&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">endpoints</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeExportOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Represents the properties of the export.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ExportDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">export_description</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ExportDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeExportOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeExportOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;export_description&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">export_description</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeGlobalTableOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Contains the details of the global table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;GlobalTableDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">global_table_description</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::GlobalTableDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeGlobalTableOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeGlobalTableOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;global_table_description&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_description</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeGlobalTableSettingsOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the global table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;GlobalTableName&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">global_table_name</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The Region-specific settings for the global table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ReplicaSettings&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">replica_settings</span>:
        <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReplicaSettingsDescription</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeGlobalTableSettingsOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeGlobalTableSettingsOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;global_table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;replica_settings&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">replica_settings</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeKinesisStreamingDestinationOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table being described.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableName&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The list of replica structures for the table being described.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;KinesisDataStreamDestinations&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">kinesis_data_stream_destinations</span>:
        <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::KinesisDataStreamDestination</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeKinesisStreamingDestinationOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeKinesisStreamingDestinationOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;kinesis_data_stream_destinations&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">kinesis_data_stream_destinations</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of a &lt;code&gt;DescribeLimits&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeLimitsOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The maximum total read capacity units that your account allows you to provision across</span>
    <span class="doccomment">/// all of your tables in this Region.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;AccountMaxReadCapacityUnits&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">account_max_read_capacity_units</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The maximum total write capacity units that your account allows you to provision across</span>
    <span class="doccomment">/// all of your tables in this Region.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;AccountMaxWriteCapacityUnits&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">account_max_write_capacity_units</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The maximum read capacity units that your account allows you to provision for a new</span>
    <span class="doccomment">/// table that you are creating in this Region, including the read capacity units</span>
    <span class="doccomment">/// provisioned for its global secondary indexes (GSIs).&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableMaxReadCapacityUnits&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_max_read_capacity_units</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The maximum write capacity units that your account allows you to provision for a new</span>
    <span class="doccomment">/// table that you are creating in this Region, including the write capacity units</span>
    <span class="doccomment">/// provisioned for its global secondary indexes (GSIs).&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableMaxWriteCapacityUnits&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_max_write_capacity_units</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeLimitsOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeLimitsOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;account_max_read_capacity_units&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">account_max_read_capacity_units</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;account_max_write_capacity_units&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">account_max_write_capacity_units</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;table_max_read_capacity_units&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_max_read_capacity_units</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;table_max_write_capacity_units&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_max_write_capacity_units</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of a &lt;code&gt;DescribeTable&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeTableOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The properties of the table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Table&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::TableDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeTableOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeTableOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeTableReplicaAutoScalingOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Represents the auto scaling properties of the table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableAutoScalingDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_auto_scaling_description</span>:
        <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::TableAutoScalingDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeTableReplicaAutoScalingOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeTableReplicaAutoScalingOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;table_auto_scaling_description&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_auto_scaling_description</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DescribeTimeToLiveOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TimeToLiveDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">time_to_live_description</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::TimeToLiveDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DescribeTimeToLiveOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DescribeTimeToLiveOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;time_to_live_description&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">time_to_live_description</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DisableKinesisStreamingDestinationOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table being modified.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableName&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The ARN for the specific Kinesis data stream.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;StreamArn&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">stream_arn</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The current status of the replication.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;DestinationStatus&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">destination_status</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::DestinationStatus</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">DisableKinesisStreamingDestinationOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;DisableKinesisStreamingDestinationOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;stream_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">stream_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;destination_status&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">destination_status</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">EnableKinesisStreamingDestinationOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table being modified.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableName&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The ARN for the specific Kinesis data stream.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;StreamArn&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">stream_arn</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The current status of the replication.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;DestinationStatus&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">destination_status</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::DestinationStatus</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">EnableKinesisStreamingDestinationOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;EnableKinesisStreamingDestinationOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;stream_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">stream_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;destination_status&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">destination_status</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ExecuteStatementOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// If a read operation was used, this property will contain the result of the reade operation; a map of attribute names and their values. For the write operations this value will be empty.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Items&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">items</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// If the response of a read request exceeds the response payload limit DynamoDB will set this value in the response. If set, you can use that this value in the subsequent request to get the remaining results.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;NextToken&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">next_token</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ExecuteStatementOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ExecuteStatementOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;items&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">items</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;next_token&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">next_token</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ExecuteTransactionOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// The response to a PartiQL transaction.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Responses&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">responses</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ItemResponse</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ExecuteTransactionOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ExecuteTransactionOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;responses&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">responses</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ExportTableToPointInTimeOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Contains a description of the table export.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ExportDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">export_description</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ExportDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ExportTableToPointInTimeOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ExportTableToPointInTimeOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;export_description&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">export_description</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of a &lt;code&gt;GetItem&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">GetItemOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;A map of attribute names to &lt;code&gt;AttributeValue&lt;/code&gt; objects, as specified</span>
    <span class="doccomment">/// by &lt;code&gt;ProjectionExpression&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Item&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">item</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The capacity units consumed by the &lt;code&gt;GetItem&lt;/code&gt; operation. The data returned</span>
    <span class="doccomment">/// includes the total provisioned throughput consumed, along with statistics for the table</span>
    <span class="doccomment">/// and any indexes involved in the operation. &lt;code&gt;ConsumedCapacity&lt;/code&gt; is only</span>
    <span class="doccomment">/// returned if the &lt;code&gt;ReturnConsumedCapacity&lt;/code&gt; parameter was specified. For more</span>
    <span class="doccomment">/// information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html&quot;&gt;Read/Write Capacity Mode&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ConsumedCapacity&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">consumed_capacity</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConsumedCapacity</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">GetItemOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;GetItemOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;item&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">item</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ListBackupsOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;List of &lt;code&gt;BackupSummary&lt;/code&gt; objects.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;BackupSummaries&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">backup_summaries</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::BackupSummary</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// The ARN of the backup last evaluated when the current page of results was returned,</span>
    <span class="doccomment">/// inclusive of the current page of results. This value may be specified as the</span>
    <span class="doccomment">/// &lt;code&gt;ExclusiveStartBackupArn&lt;/code&gt; of a new &lt;code&gt;ListBackups&lt;/code&gt; operation in order to fetch the next page of results.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// If &lt;code&gt;LastEvaluatedBackupArn&lt;/code&gt; is empty, then the last page of results has been processed and there are no</span>
    <span class="doccomment">/// more results to be retrieved.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt; If &lt;code&gt;LastEvaluatedBackupArn&lt;/code&gt; is not empty, this may or may not indicate that</span>
    <span class="doccomment">/// there is more data to be returned. All results are guaranteed to have been returned if</span>
    <span class="doccomment">/// and only if no value for &lt;code&gt;LastEvaluatedBackupArn&lt;/code&gt; is returned. &lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;LastEvaluatedBackupArn&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">last_evaluated_backup_arn</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ListBackupsOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ListBackupsOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;backup_summaries&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">backup_summaries</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;last_evaluated_backup_arn&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">last_evaluated_backup_arn</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ListContributorInsightsOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;A list of ContributorInsightsSummary.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ContributorInsightsSummaries&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">contributor_insights_summaries</span>:
        <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ContributorInsightsSummary</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A token to go to the next page if there is one.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;NextToken&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">next_token</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ListContributorInsightsOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ListContributorInsightsOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;contributor_insights_summaries&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">contributor_insights_summaries</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;next_token&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">next_token</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ListExportsOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;A list of &lt;code&gt;ExportSummary&lt;/code&gt; objects.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ExportSummaries&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">export_summaries</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ExportSummary</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;If this value is returned, there are additional results to be displayed. To retrieve</span>
    <span class="doccomment">/// them, call &lt;code&gt;ListExports&lt;/code&gt; again, with &lt;code&gt;NextToken&lt;/code&gt; set to this</span>
    <span class="doccomment">/// value.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;NextToken&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">next_token</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ListExportsOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ListExportsOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;export_summaries&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">export_summaries</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;next_token&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">next_token</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ListGlobalTablesOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;List of global table names.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;GlobalTables&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">global_tables</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::GlobalTable</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Last evaluated global table name.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;LastEvaluatedGlobalTableName&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">last_evaluated_global_table_name</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ListGlobalTablesOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ListGlobalTablesOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;global_tables&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_tables</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;last_evaluated_global_table_name&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">last_evaluated_global_table_name</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of a &lt;code&gt;ListTables&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ListTablesOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The names of the tables associated with the current account at the current endpoint. The maximum size of this array is 100.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If &lt;code&gt;LastEvaluatedTableName&lt;/code&gt; also appears in the output, you can use this value as the</span>
    <span class="doccomment">/// &lt;code&gt;ExclusiveStartTableName&lt;/code&gt; parameter in a subsequent &lt;code&gt;ListTables&lt;/code&gt; request and</span>
    <span class="doccomment">/// obtain the next page of results.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableNames&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_names</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The name of the last table in the current page of results. Use this value as the</span>
    <span class="doccomment">/// &lt;code&gt;ExclusiveStartTableName&lt;/code&gt; in a new request to obtain the next page of results, until</span>
    <span class="doccomment">/// all the table names are returned.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you do not receive a &lt;code&gt;LastEvaluatedTableName&lt;/code&gt; value in the response, this means that</span>
    <span class="doccomment">/// there are no more table names to be retrieved.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;LastEvaluatedTableName&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">last_evaluated_table_name</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ListTablesOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ListTablesOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_names&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_names</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;last_evaluated_table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">last_evaluated_table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ListTagsOfResourceOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The tags currently associated with the Amazon DynamoDB resource.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Tags&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">tags</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::Tag</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;If this value is returned, there are additional results to be displayed. To retrieve them,</span>
    <span class="doccomment">/// call ListTagsOfResource again, with NextToken set to this value.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;NextToken&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">next_token</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ListTagsOfResourceOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ListTagsOfResourceOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;tags&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">tags</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;next_token&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">next_token</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of a &lt;code&gt;PutItem&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">PutItemOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The attribute values as they appeared before the &lt;code&gt;PutItem&lt;/code&gt; operation, but only if</span>
    <span class="doccomment">/// &lt;code&gt;ReturnValues&lt;/code&gt; is specified as &lt;code&gt;ALL_OLD&lt;/code&gt; in the request. Each element</span>
    <span class="doccomment">/// consists of an attribute name and an attribute value.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Attributes&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">attributes</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The capacity units consumed by the &lt;code&gt;PutItem&lt;/code&gt; operation. The data returned</span>
    <span class="doccomment">/// includes the total provisioned throughput consumed, along with statistics for the table</span>
    <span class="doccomment">/// and any indexes involved in the operation. &lt;code&gt;ConsumedCapacity&lt;/code&gt; is only</span>
    <span class="doccomment">/// returned if the &lt;code&gt;ReturnConsumedCapacity&lt;/code&gt; parameter was specified. For more</span>
    <span class="doccomment">/// information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html&quot;&gt;Read/Write Capacity Mode&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ConsumedCapacity&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">consumed_capacity</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConsumedCapacity</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Information about item collections, if any, that were affected by the</span>
    <span class="doccomment">/// &lt;code&gt;PutItem&lt;/code&gt; operation. &lt;code&gt;ItemCollectionMetrics&lt;/code&gt;</span>
    <span class="doccomment">/// is only returned if the &lt;code&gt;ReturnItemCollectionMetrics&lt;/code&gt; parameter was specified. If the table does not have any local</span>
    <span class="doccomment">/// secondary indexes, this information is not returned in the response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Each &lt;code&gt;ItemCollectionMetrics&lt;/code&gt;</span>
    <span class="doccomment">/// element consists of:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ItemCollectionKey&lt;/code&gt; - The partition key value of the item</span>
    <span class="doccomment">/// collection. This is the same as the partition key value of the item itself.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;SizeEstimateRangeGB&lt;/code&gt; - An estimate of item collection size,</span>
    <span class="doccomment">/// in gigabytes. This value is a two-element array</span>
    <span class="doccomment">/// containing a lower bound and an upper bound for the</span>
    <span class="doccomment">/// estimate. The estimate includes the size of all the</span>
    <span class="doccomment">/// items in the table, plus the size of all attributes</span>
    <span class="doccomment">/// projected into all of the local secondary indexes on that</span>
    <span class="doccomment">/// table. Use this estimate to measure whether a local secondary index is approaching its size limit.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The estimate is subject to change over time; therefore, do not rely on the precision or accuracy of the estimate.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ItemCollectionMetrics&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">item_collection_metrics</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ItemCollectionMetrics</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">PutItemOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;PutItemOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;attributes&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">attributes</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;item_collection_metrics&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">item_collection_metrics</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of a &lt;code&gt;Query&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">QueryOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;An array of item attributes that match the query criteria. Each element in this array consists of an attribute name and the value for that attribute.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Items&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">items</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The number of items in the response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you used a &lt;code&gt;QueryFilter&lt;/code&gt; in the request, then &lt;code&gt;Count&lt;/code&gt; is the number of items</span>
    <span class="doccomment">/// returned after the filter was applied, and &lt;code&gt;ScannedCount&lt;/code&gt; is the number of</span>
    <span class="doccomment">/// matching items before the filter was applied.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you did not use a filter in the request, then &lt;code&gt;Count&lt;/code&gt; and &lt;code&gt;ScannedCount&lt;/code&gt; are the</span>
    <span class="doccomment">/// same.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Count&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">count</span>: <span class="ident">i32</span>,
    <span class="doccomment">/// &lt;p&gt;The number of items evaluated, before any &lt;code&gt;QueryFilter&lt;/code&gt; is applied. A high</span>
    <span class="doccomment">/// &lt;code&gt;ScannedCount&lt;/code&gt; value with few, or no, &lt;code&gt;Count&lt;/code&gt; results indicates an inefficient</span>
    <span class="doccomment">/// &lt;code&gt;Query&lt;/code&gt; operation. For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Count&quot;&gt;Count and ScannedCount&lt;/a&gt; in the</span>
    <span class="doccomment">/// &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you did not use a filter in the request, then &lt;code&gt;ScannedCount&lt;/code&gt; is the same as</span>
    <span class="doccomment">/// &lt;code&gt;Count&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ScannedCount&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">scanned_count</span>: <span class="ident">i32</span>,
    <span class="doccomment">/// &lt;p&gt;The primary key of the item where the operation stopped, inclusive of the previous result set. Use this value to start a new operation, excluding this value in the new request.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If &lt;code&gt;LastEvaluatedKey&lt;/code&gt; is empty, then the &quot;last page&quot; of results has been processed and there is no more data to be retrieved.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If &lt;code&gt;LastEvaluatedKey&lt;/code&gt; is not empty, it does not necessarily mean that there is more data in the result set. The only way to know when you have reached the end of the result set is when &lt;code&gt;LastEvaluatedKey&lt;/code&gt; is empty.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;LastEvaluatedKey&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">last_evaluated_key</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The capacity units consumed by the &lt;code&gt;Query&lt;/code&gt; operation. The data returned</span>
    <span class="doccomment">/// includes the total provisioned throughput consumed, along with statistics for the table</span>
    <span class="doccomment">/// and any indexes involved in the operation. &lt;code&gt;ConsumedCapacity&lt;/code&gt; is only</span>
    <span class="doccomment">/// returned if the &lt;code&gt;ReturnConsumedCapacity&lt;/code&gt; parameter was specified. For more</span>
    <span class="doccomment">/// information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html&quot;&gt;Provisioned Throughput&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer</span>
    <span class="doccomment">/// Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ConsumedCapacity&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">consumed_capacity</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConsumedCapacity</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">QueryOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;QueryOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;items&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">items</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;count&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">count</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;scanned_count&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">scanned_count</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;last_evaluated_key&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">last_evaluated_key</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RestoreTableFromBackupOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The description of the table created from an existing backup.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_description</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::TableDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">RestoreTableFromBackupOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;RestoreTableFromBackupOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_description&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_description</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RestoreTableToPointInTimeOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Represents the properties of a table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_description</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::TableDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">RestoreTableToPointInTimeOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;RestoreTableToPointInTimeOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_description&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_description</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of a &lt;code&gt;Scan&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ScanOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;An array of item attributes that match the scan criteria. Each element in this array consists of an attribute name and the value for that attribute.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Items&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">items</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The number of items in the response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you set &lt;code&gt;ScanFilter&lt;/code&gt; in the request, then &lt;code&gt;Count&lt;/code&gt; is the number of items</span>
    <span class="doccomment">/// returned after the filter was applied, and &lt;code&gt;ScannedCount&lt;/code&gt; is the number of matching items</span>
    <span class="doccomment">/// before the filter was applied.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you did not use a filter in the request, then &lt;code&gt;Count&lt;/code&gt; is the same as</span>
    <span class="doccomment">/// &lt;code&gt;ScannedCount&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Count&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">count</span>: <span class="ident">i32</span>,
    <span class="doccomment">/// &lt;p&gt;The number of items evaluated, before any &lt;code&gt;ScanFilter&lt;/code&gt; is applied. A high</span>
    <span class="doccomment">/// &lt;code&gt;ScannedCount&lt;/code&gt; value with few, or no, &lt;code&gt;Count&lt;/code&gt; results indicates an inefficient</span>
    <span class="doccomment">/// &lt;code&gt;Scan&lt;/code&gt; operation. For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Count&quot;&gt;Count and ScannedCount&lt;/a&gt; in the</span>
    <span class="doccomment">/// &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If you did not use a filter in the request, then &lt;code&gt;ScannedCount&lt;/code&gt; is the same as</span>
    <span class="doccomment">/// &lt;code&gt;Count&lt;/code&gt;.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ScannedCount&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">scanned_count</span>: <span class="ident">i32</span>,
    <span class="doccomment">/// &lt;p&gt;The primary key of the item where the operation stopped, inclusive of the previous</span>
    <span class="doccomment">/// result set. Use this value to start a new operation, excluding this value in the new</span>
    <span class="doccomment">/// request.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If &lt;code&gt;LastEvaluatedKey&lt;/code&gt; is empty, then the &quot;last page&quot; of results</span>
    <span class="doccomment">/// has been processed and there is no more data to be retrieved.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If &lt;code&gt;LastEvaluatedKey&lt;/code&gt; is not empty, it does not necessarily mean</span>
    <span class="doccomment">/// that there is more data in the result set. The only way to know when you have reached</span>
    <span class="doccomment">/// the end of the result set is when &lt;code&gt;LastEvaluatedKey&lt;/code&gt; is</span>
    <span class="doccomment">/// empty.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;LastEvaluatedKey&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">last_evaluated_key</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The capacity units consumed by the &lt;code&gt;Scan&lt;/code&gt; operation. The data returned includes the total</span>
    <span class="doccomment">/// provisioned throughput consumed, along with statistics for the table and any indexes involved</span>
    <span class="doccomment">/// in the operation. &lt;code&gt;ConsumedCapacity&lt;/code&gt; is only returned if the &lt;code&gt;ReturnConsumedCapacity&lt;/code&gt; parameter was specified.</span>
    <span class="doccomment">/// For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html&quot;&gt;Provisioned</span>
    <span class="doccomment">/// Throughput&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ConsumedCapacity&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">consumed_capacity</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConsumedCapacity</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">ScanOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;ScanOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;items&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">items</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;count&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">count</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;scanned_count&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">scanned_count</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;last_evaluated_key&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">last_evaluated_key</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">TransactGetItemsOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;If the &lt;i&gt;ReturnConsumedCapacity&lt;/i&gt; value was &lt;code&gt;TOTAL&lt;/code&gt;,</span>
    <span class="doccomment">/// this is an array of &lt;code&gt;ConsumedCapacity&lt;/code&gt; objects, one for each table</span>
    <span class="doccomment">/// addressed by &lt;code&gt;TransactGetItem&lt;/code&gt; objects in the &lt;i&gt;TransactItems&lt;/i&gt;</span>
    <span class="doccomment">/// parameter. These &lt;code&gt;ConsumedCapacity&lt;/code&gt; objects report the read-capacity</span>
    <span class="doccomment">/// units consumed by the &lt;code&gt;TransactGetItems&lt;/code&gt; call in that table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ConsumedCapacity&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">consumed_capacity</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConsumedCapacity</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;An ordered array of up to 25 &lt;code&gt;ItemResponse&lt;/code&gt; objects, each of which corresponds</span>
    <span class="doccomment">/// to the &lt;code&gt;TransactGetItem&lt;/code&gt; object in the same position in the</span>
    <span class="doccomment">/// &lt;i&gt;TransactItems&lt;/i&gt; array. Each &lt;code&gt;ItemResponse&lt;/code&gt; object</span>
    <span class="doccomment">/// contains a Map of the name-value pairs that are the projected attributes of</span>
    <span class="doccomment">/// the requested item.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;If a requested item could not be retrieved, the corresponding &lt;code&gt;ItemResponse&lt;/code&gt;</span>
    <span class="doccomment">/// object is Null, or if the requested item has no projected attributes, the corresponding</span>
    <span class="doccomment">/// &lt;code&gt;ItemResponse&lt;/code&gt; object is an empty Map. &lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Responses&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">responses</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ItemResponse</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">TransactGetItemsOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;TransactGetItemsOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;responses&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">responses</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">TransactWriteItemsOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The capacity units consumed by the entire &lt;code&gt;TransactWriteItems&lt;/code&gt;</span>
    <span class="doccomment">/// operation. The values of the list are ordered according to</span>
    <span class="doccomment">/// the ordering of the &lt;code&gt;TransactItems&lt;/code&gt; request parameter.</span>
    <span class="doccomment">/// &lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ConsumedCapacity&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">consumed_capacity</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConsumedCapacity</span><span class="op">&gt;</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;A list of tables that were processed by &lt;code&gt;TransactWriteItems&lt;/code&gt; and, for each</span>
    <span class="doccomment">/// table, information about any item collections that were affected by individual</span>
    <span class="doccomment">/// &lt;code&gt;UpdateItem&lt;/code&gt;, &lt;code&gt;PutItem&lt;/code&gt;, or &lt;code&gt;DeleteItem&lt;/code&gt;</span>
    <span class="doccomment">/// operations. &lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ItemCollectionMetrics&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">item_collection_metrics</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span>
            <span class="ident">std::string::String</span>,
            <span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ItemCollectionMetrics</span><span class="op">&gt;</span>,
        <span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">TransactWriteItemsOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;TransactWriteItemsOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;item_collection_metrics&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">item_collection_metrics</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateContinuousBackupsOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Represents the continuous backups and point in time recovery settings on the table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ContinuousBackupsDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">continuous_backups_description</span>:
        <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ContinuousBackupsDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateContinuousBackupsOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateContinuousBackupsOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;continuous_backups_description&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">continuous_backups_description</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateContributorInsightsOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableName&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_name</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The name of the global secondary index, if applicable.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;IndexName&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">index_name</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The status of contributor insights&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ContributorInsightsStatus&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">contributor_insights_status</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ContributorInsightsStatus</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateContributorInsightsOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateContributorInsightsOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;index_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">index_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;contributor_insights_status&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">contributor_insights_status</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateGlobalTableOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Contains the details of the global table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;GlobalTableDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">global_table_description</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::GlobalTableDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateGlobalTableOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateGlobalTableOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;global_table_description&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_description</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateGlobalTableSettingsOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;The name of the global table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;GlobalTableName&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">global_table_name</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::string::String</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The Region-specific settings for the global table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ReplicaSettings&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">replica_settings</span>:
        <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="ident">std::vec::Vec</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ReplicaSettingsDescription</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateGlobalTableSettingsOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateGlobalTableSettingsOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;global_table_name&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">global_table_name</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;replica_settings&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">replica_settings</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of an &lt;code&gt;UpdateItem&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateItemOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;A map of attribute values as they appear before or after the &lt;code&gt;UpdateItem&lt;/code&gt;</span>
    <span class="doccomment">/// operation, as determined by the &lt;code&gt;ReturnValues&lt;/code&gt; parameter.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The &lt;code&gt;Attributes&lt;/code&gt; map is only present if &lt;code&gt;ReturnValues&lt;/code&gt; was</span>
    <span class="doccomment">/// specified as something other than &lt;code&gt;NONE&lt;/code&gt; in the request. Each element</span>
    <span class="doccomment">/// represents one attribute.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;Attributes&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">attributes</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span>
        <span class="ident">std::collections::HashMap</span><span class="op">&lt;</span><span class="ident">std::string::String</span>, <span class="kw">crate</span><span class="ident">::model::AttributeValue</span><span class="op">&gt;</span>,
    <span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;The capacity units consumed by the &lt;code&gt;UpdateItem&lt;/code&gt; operation. The data returned includes the total</span>
    <span class="doccomment">/// provisioned throughput consumed, along with statistics for the table and any indexes involved</span>
    <span class="doccomment">/// in the operation. &lt;code&gt;ConsumedCapacity&lt;/code&gt; is only returned if the &lt;code&gt;ReturnConsumedCapacity&lt;/code&gt; parameter was specified.</span>
    <span class="doccomment">/// For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html&quot;&gt;Provisioned</span>
    <span class="doccomment">/// Throughput&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ConsumedCapacity&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">consumed_capacity</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ConsumedCapacity</span><span class="op">&gt;</span>,
    <span class="doccomment">/// &lt;p&gt;Information about item collections, if any, that were affected by the</span>
    <span class="doccomment">/// &lt;code&gt;UpdateItem&lt;/code&gt; operation.</span>
    <span class="doccomment">/// &lt;code&gt;ItemCollectionMetrics&lt;/code&gt; is only returned if the &lt;code&gt;ReturnItemCollectionMetrics&lt;/code&gt; parameter was specified. If the table</span>
    <span class="doccomment">/// does not have any local secondary indexes, this information is not</span>
    <span class="doccomment">/// returned in the response.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;Each &lt;code&gt;ItemCollectionMetrics&lt;/code&gt;</span>
    <span class="doccomment">/// element consists of:&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;ul&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;ItemCollectionKey&lt;/code&gt; - The partition key value of the item</span>
    <span class="doccomment">/// collection. This is the same as the partition key value of the item itself.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;li&gt;</span>
    <span class="doccomment">/// &lt;p&gt;</span>
    <span class="doccomment">/// &lt;code&gt;SizeEstimateRangeGB&lt;/code&gt; - An estimate of item collection size,</span>
    <span class="doccomment">/// in gigabytes. This value is a two-element array</span>
    <span class="doccomment">/// containing a lower bound and an upper bound for the</span>
    <span class="doccomment">/// estimate. The estimate includes the size of all the</span>
    <span class="doccomment">/// items in the table, plus the size of all attributes</span>
    <span class="doccomment">/// projected into all of the local secondary indexes on that</span>
    <span class="doccomment">/// table. Use this estimate to measure whether a local secondary index is approaching its size limit.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;p&gt;The estimate is subject to change over time; therefore, do not rely on the precision or accuracy of the estimate.&lt;/p&gt;</span>
    <span class="doccomment">/// &lt;/li&gt;</span>
    <span class="doccomment">/// &lt;/ul&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;ItemCollectionMetrics&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">item_collection_metrics</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::ItemCollectionMetrics</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateItemOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateItemOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;attributes&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">attributes</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;consumed_capacity&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">consumed_capacity</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;item_collection_metrics&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">item_collection_metrics</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="doccomment">/// &lt;p&gt;Represents the output of an &lt;code&gt;UpdateTable&lt;/code&gt; operation.&lt;/p&gt;</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateTableOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Represents the properties of the table.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_description</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::TableDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateTableOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateTableOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(<span class="string">&quot;table_description&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_description</span>);
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateTableReplicaAutoScalingOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Returns information about the auto scaling settings of a table with replicas.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TableAutoScalingDescription&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">table_auto_scaling_description</span>:
        <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::TableAutoScalingDescription</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateTableReplicaAutoScalingOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateTableReplicaAutoScalingOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;table_auto_scaling_description&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">table_auto_scaling_description</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}

<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">std::default::Default</span>, <span class="ident">serde::Deserialize</span>, <span class="ident">std::clone::Clone</span>, <span class="ident">std::cmp::PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UpdateTimeToLiveOutputBody</span> {
    <span class="doccomment">/// &lt;p&gt;Represents the output of an &lt;code&gt;UpdateTimeToLive&lt;/code&gt; operation.&lt;/p&gt;</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;TimeToLiveSpecification&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">default</span>)]</span>
    <span class="kw">pub</span> <span class="ident">time_to_live_specification</span>: <span class="ident">std::option::Option</span><span class="op">&lt;</span><span class="kw">crate</span><span class="ident">::model::TimeToLiveSpecification</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">std::fmt::Debug</span> <span class="kw">for</span> <span class="ident">UpdateTimeToLiveOutputBody</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">std::fmt::Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">std::fmt::Result</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">formatter</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;UpdateTimeToLiveOutputBody&quot;</span>);
        <span class="ident">formatter</span>.<span class="ident">field</span>(
            <span class="string">&quot;time_to_live_specification&quot;</span>,
            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">time_to_live_specification</span>,
        );
        <span class="ident">formatter</span>.<span class="ident">finish</span>()
    }
}
</pre></div>
</section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="aws_sdk_dynamodb" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script>
</body></html>